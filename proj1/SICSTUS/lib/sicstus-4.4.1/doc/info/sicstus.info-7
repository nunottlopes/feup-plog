This is sicstus.info, produced by makeinfo version 5.2 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated March 15, 2018.


File: sicstus.info,  Node: Passing Control to Tk,  Next: Housekeeping,  Prev: Servicing Tk Events,  Up: The Tcl/Tk Prolog Library

10.39.4.6 Passing Control to Tk
...............................

There is a predicate for passing control completely over to Tk, the
'tk_main_loop/0' command.  This passes control to Tk until all windows
in all the Tcl/Tk interpreters in the Prolog have have been destroyed:

     tk_main_loop


File: sicstus.info,  Node: Housekeeping,  Next: Summary,  Prev: Passing Control to Tk,  Up: The Tcl/Tk Prolog Library

10.39.4.7 Housekeeping functions
................................

Here we will described the functions that do not fit into any of the
above categories and are essentially housekeeping functions.

   There is a predicate that returns a reference to the main window of a
Tcl/Tk interpreter:

     tk_main_window(+TCLINTERPRETER, -TKWINDOW)

which given a reference to a Tcl interpreter TCLNTERPRETER, returns a
reference to its main window in TKWINDOW.

   The window reference can then be used in 'tk_destroy_window/1':

     tk_destroy_window(+TKWINDOW)

which destroys the window or widget referenced by TKWINDOW and all of
its sub-widgets.

   The predicate 'tk_make_window_exist/1' also takes a window reference:

     tk_make_window_exist(+TKWINDOW)

which causes the window referenced by TKWINDOW in the Tcl interpreter
TCLINTERPRETER to be immediately mapped to the display.  This is useful
because normally Tk delays displaying new information for a long as
possible (waiting until the machine is idle, for example), but using
this call causes Tk to display the window immediately.

   There is a predicate for determining how many main windows, and hence
Tcl/Tk interpreters (excluding simple Tcl interpreters), are currently
in use:

     tk_num_main_windows(-NUMBEROFWINDOWS)

which returns an integer in the variable NUMBEROFWINDOWS.


File: sicstus.info,  Node: Summary,  Prev: Housekeeping,  Up: The Tcl/Tk Prolog Library

10.39.4.8 Summary
.................

The functions provided by the SICStus Prolog Tcl/Tk library can be
grouped in two ways: by function, and by package.

   By function, we can group them like this:

   * basic functions
     'tcl_new/1'
          create a Tcl interpreter
     'tcl_delete/1'
          remove a Tcl interpreter
     'tk_new/2'
          create a Tcl interpreter with Tk extensions

   * evaluation functions
     'tcl_eval/3'
          evaluate a Tcl expression from Prolog
     'prolog'
          evaluate a Prolog expression from Tcl

   * Prolog event queue functions
     'tcl_event/3'
          evaluate a Tcl expression and return a Prolog queue event list
     'tk_next_event/[2,3]'
          pass control to Tk until a Prolog queue event happens and
          return the head of the queue
     'prolog_event'
          place a Prolog term on the Prolog event queue from Tcl

   * servicing Tcl and Tk events
     'tk_do_one_event/[0,1]'
          pass control to Tk until one Tk event is serviced
     'tk_next_event/[2,3]'
          also services Tk events but returns when a Prolog queue event
          happens and returns the head of the queue

   * passing control completely to Tk
     'tk_main_loop/0'
          control passed to Tk until all windows in all Tcl/Tk
          interpreters are gone

   * housekeeping
     'tk_main_window/2'
          return reference to main in of a Tcl/Tk interpreter
     'tk_destroy_window/1'
          destroy a window or widget
     'tk_make_window_exist/1'
          force display of a window or widget
     'tk_num_main_windows/1'
          return a count of the total number of Tk main windows existing
          in the system

   By package, we can group them like this:

   * predicates for Prolog to interact with Tcl interpreters
     'tcl_new/1'
          create a Tcl interpreter
     'tcl_delete/1'
          remove a Tcl interpreter
     'tcl_eval/3'
          evaluate a Tcl expression from Prolog
     'tcl_event/3'
          evaluate a Tcl expression and return a Prolog event list

   * predicates for Prolog to interact with Tcl interpreters with Tk
     extensions
     'tk_new/2'
          create a Tcl interpreter with Tk extensions
     'tk_do_one_event/[0,1]'
          pass control to Tk until one Tk event is serviced
     'tk_next_event/[2,3]'
          also services Tk events but returns when a Prolog queue event
          happens and returns the head of the queue
     'tk_main_loop/0'
          control passed to Tk until all windows in all Tcl/Tk
          interpreters are gone
     'tk_main_window/2'
          return reference to main in of a Tcl/Tk interpreter
     'tk_destroy_window/1'
          destroy a window or widget
     'tk_make_window_exist/1'
          force display of a window or widget
     'tk_num_main_windows/1'
          return a count of the total number of Tk main windows existing
          in the system

   * commands for the Tcl interpreters to interact with the Prolog
     system
     'prolog'
          evaluate a Prolog expression from Tcl
     'prolog_event'
          place a Prolog term on the Prolog event queue from Tcl

   In the next section we will discuss how to use the 'tcltk' library to
build graphical user interfaces to Prolog applications.  More
specifically we will discuss the ways in which cooperation between
Prolog and Tcl/Tk can be arranged: how to achieve them, and their
benefits.


File: sicstus.info,  Node: Putting It All Together,  Next: Quick Reference,  Prev: The Tcl/Tk Prolog Library,  Up: lib-tcltk

10.39.5 Putting It All Together
-------------------------------

At this point we now know Tcl, the Tk extensions, and how they can be
integrated into SICStus Prolog through the 'tcltk' library module.  The
next problem is how to get all this to work together to produce a
coherent application.  Because Tcl can make Prolog calls and Prolog can
make Tcl calls it is easy to create programming spaghetti.  In this
section we will discuss some general principles of organizing the Prolog
and Tcl code to make writing applications easier.

   The first thing to do is to review the tools that we have.  We have
two programming systems: Prolog and Tcl/Tk.  They can interact in the
following ways:

   * Prolog evaluates a Tcl expression in a Tcl interpreter, using
     'tcl_eval'
   * Tcl evaluates a Prolog expression in the Prolog interpreter, using
     'prolog'
   * Prolog evaluates a Tcl expression in a Tcl interpreter and waits
     for a Prolog event, using 'tcl_event'
   * Prolog waits for a Prolog event from a Tcl interpreter, using
     'tk_next_event'
   * Tcl sends a Prolog predicate to Prolog on a Prolog event queue
     using 'prolog_event'

   With these interaction primitives there are three basic ways in which
Prolog and Tcl/Tk can be organized:

  1. Tcl the master, Prolog the slave: program control is with Tcl,
     which makes occasional calls to Prolog, through the 'prolog'
     function.

  2. Prolog the master, Tcl the slave: program control is with Prolog,
     which makes occasional call to Tcl through the 'tcl_eval' function

  3. Prolog and Tcl share control: program control is shared with Tcl
     and Prolog interacting via the Prolog event queue, through
     'tcl_event', 'tk_next_event', and 'prolog_event'.

   These are three ways of organizing cooperation between Tcl/Tk and
Prolog to produce an application.  In practice an application my use
only one of these methods throughout, or may use a combination of them
where appropriate.  We describe them here so that the developer can see
the different patterns of organization and can pick those relevant to
their application.

* Menu:

* Tcl The Master:: Tcl The Master, Prolog The Slave
* Prolog The Master:: Prolog The Master, Tk The Slave
* Prolog And Tcl Interact through Prolog Event Queue:: Prolog And Tcl Interact through Prolog Event Queue
* The Whole 8-Queens Example:: The Whole 8-Queens Example


File: sicstus.info,  Node: Tcl The Master,  Next: Prolog The Master,  Up: Putting It All Together

10.39.5.1 Tcl The Master, Prolog The Slave
..........................................

This is the classical way that GUIs are bolted onto applications.  The
slave (in this case Prolog) sits mostly idle while the user interacts
with the GUI, for example filling in a form.  When some action happens
in the GUI that requires information from the slave (a form submit, for
example), the slave is called, performs a calculation, and the GUI
retrieves the result and updates its display accordingly.

   In our Prolog+Tcl/Tk setting this involves the following steps:

   * start Prolog and load the Tcl/Tk library
   * load Prolog application code
   * start a Tcl/Tk interpreter through 'tk_new/2'
   * set up the Tk GUI through calls to 'tcl_eval/3'
   * pass control to Tcl/Tk through 'tk_main_loop'

   Some of The Tk widgets in the GUI will have "callbacks" to Prolog,
i.e. they will call the 'prolog' Tcl command.  When the Prolog call
returns, the values stored in the 'prolog_variables' array in the Tcl
interpreter can then be used by Tcl to update the display.

   Here is a simple example of a callback.  The Prolog part is this:

     :- use_module(library(tcltk)).

     hello('world').

     go :-
         tk_new([], Tcl),
         tcl_eval(Tcl, 'source simple.tcl', _),
         tk_main_loop.

which just loads the 'library(tcltk)', defines a 'hello/1' data clause,
and 'go/0', which starts a new Tcl/Tk interpreter, loads the code
'simple.tcl' into it, and passes control to Tcl/Tk.

   The Tcl part, 'simple.tcl', is this:

     label .l -textvariable tvar
     button .b -text "push me" -command { call_and_display }
     pack .l .b -side top

     proc call_and_display { } {
         global tvar

         prolog "hello(X)"
         set tvar $prolog_variables(X)
     }

which creates a label, with an associated text variable, and a button,
that has a call back procedure, 'call_and_display', attached to it.
When the button is pressed, 'call_and_display' is executed, which simply
evaluates the goal 'hello(X)' in Prolog and the text variable of the
label '.l' to whatever 'X' becomes bound to, which happens to be
'world'.  In short, pressing the button causes the word 'world' to be
displayed in the label.

   Having Tcl as the master and Prolog as the slave, although a simple
model to understand and implement, does have disadvantages.  The Tcl
command 'prolog' is determinate, i.e. it can return only one result with
no backtracking.  If more than one result is needed, then it means
either performing some kind of all-solutions search and returning a list
of results for Tcl to process, or asserting a clause into the Prolog
clause store reflecting the state of the computation.

   Here is an example of how an all-solutions search can be done.  It is
a program that calculates the outcome of certain ancestor relationships;
i.e. enter the name of a person, click on a button and it will tell you
the mother, father, parents or ancestors of that person.

   The Prolog portion looks like this (see also
'library('tcltk/examples/ancestors.pl')'):

     :- use_module(library(tcltk)).

     go :- tk_new([name('ancestors')], X),
         tcl_eval(X, 'source ancestors.tcl', _),
         tk_main_loop,
         tcl_delete(X).

     father(ann, fred).
     father(fred, jim).
     mother(ann, lynn).
     mother(fred, lucy).
     father(jim, sam).

     parent(X, Y) :- mother(X, Y).
     parent(X, Y) :- father(X, Y).

     ancestor(X, Y) :- parent(X, Y).
     ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).

     all_ancestors(X, Z) :- findall(Y, ancestor(X, Y), Z).

     all_parents(X, Z) :-   findall(Y, parent(X, Y), Z).

   This program consists of three parts.  The first part is defined by
'go/0', the now familiar way in which a Prolog program can create a
Tcl/Tk interpreter, load a Tcl file into that interpreter, and pass
control over to the interpreter.

   The second part is a small database of mother/father relationships
between certain people through the clauses 'mother/2' and 'father/2'.

   The third part is a set of "rules" for determining certain
relationships between people: 'parent/2', 'ancestor/2',
'all_ancestors/2' and 'all_parents/2'.

   The Tcl part looks like this (see also
'library('tcltk/examples/ancestors.tcl')'):

                                                       _% ancestors.pl_
     #!/usr/bin/wish

     # set up the tk display

     # construct text filler labels
     label .search_for -text "SEARCHING FOR THE" -anchor w
     label .of         -text "OF"                -anchor w
     label .gives      -text "GIVES"             -anchor w

     # construct frame to hold buttons
     frame .button_frame

     # construct radio button group
     radiobutton .mother    -text mother    -variable type -value mother
     radiobutton .father    -text father    -variable type -value father
     radiobutton .parents   -text parents   -variable type -value parents
     radiobutton .ancestors -text ancestors -variable type -value ancestors

     # add behaviors to radio buttons
     .mother    config -command { one_solution mother $name}
     .father    config -command { one_solution father $name}
     .parents   config -command { all_solutions all_parents $name}
     .ancestors config -command { all_solutions all_ancestors $name}

     # create entry box and result display widgets
     entry .name -textvariable name
     label .result -text ">>> result <<<" -relief sunken -anchor nw -justify left

     # pack buttons into button frame
     pack .mother .father .parents .ancestors -fill x -side left -in .button_frame

     # pack everything together into the main window
     pack .search_for .button_frame .of .name .gives .result -side top -fill x

     # now everything is set up
                                                       _% ancestors.pl_
     # defined the callback procedures

     # called for one solution results
     proc one_solution { type name } {
         if [prolog "${type}('$name', R)"] {
             display_result $prolog_variables(R)
         } else {
             display_result ""
         }
     }

     # called for all solution results
     proc all_solutions { type name } {
         prolog  "${type}('$name', R)"
         display_result $prolog_variables(R)
     }

     # display the result of the search in the results box
     proc display_result { result } {
         if { $result != "" } {
     # create a multiline result
             .result config -text $result
         } else {
             .result config -text "*** no result ***"
         }
     }


 [image src="images/tcltkancestors.png" text="" ]
                         Ancestors Calculator

   This program is in two parts.  The first part sets up the Tk display,
which consists of four radiobuttons to choose the kind of relationship
we want to calculate, an entry box to put the name of the person we want
to calculate the relationship over, and a label in which to display the
result.

   Each radio buttons has an associated callback.  Clicking on the radio
button will invoke the appropriate callback, apply the appropriate
relationship to the name entered in the text entry box, and display the
result in the results label.

   The second part consists of the callback procedures themselves.
There are actually just two of them: one for a single solution
calculation, and one for an all-solutions calculation.  The single
solution callback is used when we want to know the mother or father as
we know that a person can have only one of each.  The all-solutions
callback is used when we want to know the parents or ancestors as we
know that these can return more than one results.  (We could have used
the all-solutions callback for the single solutions cases too, but we
would like to illustrate the difference in the two approaches.)  There
is little difference between the two approaches, except that in the
single solution callback, it is possible that the call to Prolog will
fail, so we wrap it in an 'if' ... 'else' construct to catch this case.
An all-solutions search, however, cannot fail, and so the 'if' ...
'else' is not needed.

   But there are some technical problems too with this approach.  During
a callback Tk events are not serviced until the callback returns.  For
Prolog callbacks that take a very short time to complete this is not a
problem, but in other cases, for example during a long search call when
the callback takes a significant time to complete, this can cause
problems.  Imagine that, in our example, we had a vast database
describing the parent relationships of millions of people.  Performing
an all-solutions ancestors search could take a long time.  The classic
problem is that the GUI no longer reacts to the user until the callback
completes.

   The solution to this is to sprinkle 'tk_do_one_event/[0,1]' calls
throughout the critical parts of the Prolog code, to keep various kinds
of Tk events serviced.

   If this method is used in its purest form, then it is recommended
that after initialization and passing of control to Tcl, Prolog do not
make calls to Tcl through 'tcl_eval/3'.  This is to avoid programming
spaghetti.  In the pure master/slave relationship it is a general
principle that the master only call the slave, and not the other way
around.


File: sicstus.info,  Node: Prolog The Master,  Next: Prolog And Tcl Interact through Prolog Event Queue,  Prev: Tcl The Master,  Up: Putting It All Together

10.39.5.2 Prolog The Master, Tk The Slave
.........................................

The second approach is to have Prolog be the master and Tk the slave.
This is suitable when heavy processing is done in the Prolog code and Tk
is used mostly to display the state of the computation in some way
rather than as a traditional GUI; i.e. during computation Prolog often
makes calls to Tk to show some state, but the user rarely interacts with
the application.

   In our Prolog+Tcl/Tk setting this involves the following steps:

   * start Prolog and load the Tcl/Tk library
   * load Prolog application code
   * start a Tcl/Tk interpreter through 'tk_new/2'
   * set up the Tk GUI through calls to 'tcl_eval/3'
   * Prolog calls 'tcl_eval' to update the Tk display
   * values are passed to Prolog through the Result string of 'tcl_eval'

   Again it its purest form, Prolog makes calls to Tcl, but Tcl does not
make calls to Prolog.  The result of a call to Tcl is either passed back
through the 'Result' variable of a 'tcl_eval/3' call.

   A good example of this is the Tcl/Tk display for our 8-queens
problem, that we saw earlier; *note Queens Display::.

   We will now fill out the example by presenting the Prolog master
part.  The Prolog program calculates a solution to the 8-queens problem
and then makes calls Tcl/Tk to display the solution.  In this way Tcl/Tk
is the slave, just being used as a simple display.

   We have already seen the Tcl/Tk part, but here is the Prolog part for
generating a solution and displaying it:

     :- use_module(library(tcltk)).
     :- use_module(library(lists)).

     go :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source queens.tcl', _),
         tk_next_event(Tcl, Event),
         queens(8, Qs),
         reverse(L, LR),
         tcl_eval(Tcl, [show_solution, br(LR)], _),
         fail.
     go.

     queens(N, Qs) :-
         range(1, N, Ns),
         queens(Ns, [], Qs).

     queens(UnplacedQs, SafeQs, Qs) :-
         select(Q, UnplacedQs, UnplacedQs1),
         \+ attack(Q, SafeQs),
         queens(UnplacedQs1, [Q|SafeQs], Qs).
         queens([], Qs, Qs).

     attack(X, Xs) :- attack(X, 1, Xs).

     attack(X, N, [Y|_Ys]) :- X is Y + N.
     attack(X, N, [Y|_Ys]) :- X is Y - N.
     attack(X, N, [_Y|Ys]) :-
         N1 is N + 1,
     attack(X, N1, Ys).

     range(M, N, [M|Ns]) :-
         M < N,
         M1 is M + 1,
         range(M1, N, Ns).
     range(N, N, [N]).

     :- go.

   All this simply does it to create a Tcl/Tk interpreter, load the Tcl
code for displaying queens into it, generate a solution to the 8-queens
problem as a list of integers, and then calls 'show_solution/2' in the
Tcl interpreter to display the solution.  At the end of first clause for
'go/0' is a fail clause that turns 'go/0' into a failure driven loop.
The result of this is that the program will calculate all the solutions
to the 8-queens problem, displaying them rapidly one after the other,
until there are none left.


File: sicstus.info,  Node: Prolog And Tcl Interact through Prolog Event Queue,  Next: The Whole 8-Queens Example,  Prev: Prolog The Master,  Up: Putting It All Together

10.39.5.3 Prolog And Tcl Interact through Prolog Event Queue
............................................................

In the previous two methods, one of the language systems was the master
and the other slave, the master called the slave to perform some action
or calculation, the slave sits waiting until the master calls it.  We
have seen that this has disadvantages when Prolog is the slave in that
the state of the Prolog call is lost.  Each Prolog call starts from the
beginning unless we save the state using message database manipulation
through calls to 'assert' and 'retract'.

   Using the Prolog event queue, however, it is possible to get a more
balanced model where the two language systems cooperate without either
really being the master or the slave.

   One way to do this is the following:

   * Prolog is started
   * load Tcl/Tk library
   * load and set up the Tcl side of the program
   * Prolog starts a processing loop
   * it periodically checks for a Prolog event and processes it
   * Prolog updates the Tcl display through 'tcl_eval' calls

   What can processing a Prolog event mean?  Well, for example, a button
press from Tk could tell the Prolog program to finish or to start
processing something else.  The Tcl program is not making an explicit
call to the Prolog system but sending a message to Prolog.  The Prolog
system can pick up the message and process it when it chooses, in the
meantime keeping its run state and variables intact.

   To illustrate this, we return to the 8-queens example.  If Tcl/Tk is
the master and Prolog the slave, then we have shown that using a
callback to Prolog, we can imagine that we hit a button, call Prolog to
get a solution and then display it.  But how do we get the next
solution?  We could get all the solutions, and then use Tcl/Tk code to
step through them, but that does not seem satisfactory.  If we use the
Prolog is the master and Tcl/Tk is the slave model, then we have shown
how we can use Tcl/Tk to display the solutions generate from the Prolog
side: Prolog just make a call to the Tcl side when it has a solution.
But in this model Tcl/Tk widgets do not interact with the Prolog side;
Tcl/Tk is mearly an add-on display to Prolog.

   But using the Prolog event queue we can get the best of both worlds:
Prolog can generate each solution in turn as Tcl/Tk asks for it.

   Here is the code on the Prolog side that does this.  (We have left
out parts of the code that have not changed from our previous example,
*note Queens Display::).

     :- use_module(library(tcltk)).
     :- use_module(library(lists)).

     setup :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source queens2.tcl', _),
         tk_next_event(Tcl, Event),
         (   Event = next -> go(Tcl)
         ;   closedown(Tcl)
         ).

     closedown(Tcl) :-
         tcl_delete(Tcl).

     go(Tcl) :-
         tcl_eval(Tcl, 'clear_board', _),
         queens(8, Qs),
         show_solution(Qs),
         tk_next_event(Tcl, Event),
         (   Event = next -> fail
         ;   closedown(Tcl)
         ).
     go(Tcl) :-
         tcl_eval(Tcl, 'disable_next', _),
         tcl_eval(Tcl, 'clear_board', _),
         tk_next_event(Tcl, _Event),
         closedown(Tcl).

     show_solution(Tcl, L) :-
         tcl(Tcl),
         reverse(L, LR),
         tcl_eval(Tcl, [show_solution, br(LR)], _),
         tk_do_all_events.

   Notice here that we have used 'tk_next_event/2' in several places.
The code is executed by calling 'setup/0'.  As usual, this loads in the
Tcl part of the program, but then Prolog waits for a message from the
Tcl side.  This message can either be 'next', indicating that we want to
show the next solution, or 'stop', indicating that we want to stop the
program.

   If 'next' is received, then the program goes on to execute 'go/1'.
What this does it to first calculate a solution to the 8-queens problem,
displays the solution through 'show_solution/2', and then waits for
another message from Tcl/Tk.  Again this can be either 'next' or 'stop'.
If 'next', then the program goes into the failure part of a failure
driven loop and generates and displays the next solution.

   If at any time 'stop' is received, then the program terminates
gracefully, cleaning up the Tcl interpreter.

   On the Tcl/Tk side all we need are a couple of buttons: one for
sending the 'next' message, and the other for sending the 'stop'
message.

     button .next -text next -command {prolog_event next}
     pack .next

     button .stop -text stop -command {prolog_event stop}
     pack .stop

   (We could get more sophisticated.  We might want it so that when the
button it is depressed until Prolog has finished processing the last
message, when the button is allowed to pop back up.  This would avoid
the problem of the user pressing the button many times while the program
is still processing the last request.  We leave this as an exercise for
the reader.)


File: sicstus.info,  Node: The Whole 8-Queens Example,  Prev: Prolog And Tcl Interact through Prolog Event Queue,  Up: Putting It All Together

10.39.5.4 The Whole 8-Queens Example
....................................

To finish off, we our complete 8-queens program.

   Here is the Prolog part, which we have covered in previous sections.
The code is in 'library('tcltk/examples/8-queens.pl')':

                                                        _% 8-queens.pl_
     :- use_module(library(tcltk)).
     :- use_module(library(lists)).

     setup :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source 8-queens.tcl', _),
         tk_next_event(Tcl, Event),
         (   Event = next -> go(Tcl)
         ;   closedown(Tcl)
         ).

     closedown(Tcl) :-
         tcl_delete(Tcl).

     go(Tcl) :-
         tcl_eval(Tcl, 'clear_board', _),
         queens(8, Qs),
         show_solution(Tcl,Qs),
         tk_next_event(Tcl, Event),
         (   Event = next -> fail
         ;   closedown(Tcl)
         ).
     go(Tcl) :-
         tcl_eval(Tcl, 'disable_next', _),
         tcl_eval(Tcl, 'clear_board', _),
         tk_next_event(Tcl, _Event),
         closedown(Tcl).
                                                        _% 8-queens.pl_
     queens(N, Qs) :-
         range(1, N, Ns),
         queens(Ns, [], Qs).

     queens(UnplacedQs, SafeQs, Qs) :-
         select(Q, UnplacedQs, UnplacedQs1),
         \+ attack(Q, SafeQs),
         queens(UnplacedQs1, [Q|SafeQs], Qs).
         queens([], Qs, Qs).

     attack(X, Xs) :- attack(X, 1, Xs).

     attack(X, N, [Y|_Ys]) :- X is Y + N.
     attack(X, N, [Y|_Ys]) :- X is Y - N.
     attack(X, N, [_Y|Ys]) :-
         N1 is N + 1,
         attack(X, N1, Ys).

     range(M, N, [M|Ns]) :-
         M < N,
         M1 is M + 1,
         range(M1, N, Ns).
     range(N, N, [N]).

     show_solution(Tcl, L) :-
         reverse(L, LR),
         tcl_eval(Tcl, [show_solution, br(LR)], _),
         tk_do_all_events.

     tk_do_all_events :-
         tk_do_one_event, !,
         tk_do_all_events.
     tk_do_all_events.

     :- setup.

   And here is the Tcl/Tk part, which we have covered in bits and pieces
but here is the whole thing.  We have added an enhancement where when
the mouse is moved over one of the queens, the squares that the queen
attacks are highlighted.  Move the mouse away and the board reverts to
normal.  This is an illustration of how the Tcl/Tk 'bind' feature can be
used.  The code is in 'library('tcltk/examples/8-queens.tcl')':

                                                       _# 8-queens.tcl_
     #! /usr/bin/wish
     # create an 8x8 grid of labels
     proc setup_display { } {
         frame .queens -background black
         pack .queens

         for {set y 1} {$y <= 8} {incr y} {
             for {set x 1} {$x <= 8} {incr x} {

                 # create a label and display a queen in it
                 label .queens.$x-$y -bitmap @bitmaps/q64s.bm -relief flat

                 # color alternate squares with different colors
                 # to create the chessboard pattern
                 if { [expr ($x + $y) % 2] } {
                     .queens.$x-$y config -background #ffff99
                 } else {
                     .queens.$x-$y config -background #66ff99
                 }

                 # set foreground to the background color to
                 # make queen image invisible
                 .queens.$x-$y config -foreground [.queens.$x-$y cget -background]

                 # bind the mouse to highlight the squares attacked by a
                 # queen on this square
                 bind .queens.$x-$y <Enter> "highlight_attack on $x $y"
                 bind .queens.$x-$y <Leave> "highlight_attack off $x $y"

                 # arrange the queens in a grid
                 grid .queens.$x-$y -row $y -column $x -padx 1 -pady 1

                 }
            }
     }
                                                       _# 8-queens.tcl_
     # clear a whole column
     proc reset_column { column } {
         for {set y 1 } { $y <= 8 } {incr y} {
             set_queens $column $y ""
         }
     }

     # place or unplace a queen
     proc set_queens { x y v } {
         if { $v == "Q" } {
             .queens.$x-$y config -foreground black
         } else {
             .queens.$x-$y config -foreground [.queens.$x-$y cget -background]
         }
     }

     # place a queen on a column
     proc place_queen { x y } {
         reset_column $x
         set_queens $x $y Q
     }

     # clear the whole board by clearing each column in turn
     proc clear_board { } {
         for { set x 1 } {$x <= 8} {incr x} {
             reset_column $x
         }
     }

     # given a solution as a list of queens in column positions
     # place each queen on the board
     proc show_solution { solution } {
         clear_board
         set x 1
         foreach y $solution {
             place_queen $x $y
             incr x
         }
     }
                                                       _# 8-queens.tcl_
     proc highlight_square { mode x y } {
         # check if the square we want to highlight is on the board
         if { $x < 1 || $y < 1 || $x > 8 || $y > 8 } { return };

         # if turning the square on make it red,
         # otherwise determine what color it should be and set it to that
         if { $mode == "on" } { set color red } else {
             if { [expr ($x + $y) % 2] } { set color "#ffff99" } else {
                 set color "#66ff99" }
             }

             # get the current settings
             set bg [ .queens.$x-$y cget -bg ]
             set fg [ .queens.$x-$y cget -fg ]

             # if the current foreground and background are the same
             # there is no queen there
             if { $bg == $fg } {
                 # no queens
                 .queens.$x-$y config -bg $color -fg $color
              } else {
                  .queens.$x-$y config -bg $color
         }
     }

     proc highlight_attack { mode x y } {
         # get current colors of square at x y
         set bg [ .queens.$x-$y cget -bg ]
         set fg [ .queens.$x-$y cget -fg ]

         # no queen there, give up
         if { $bg == $fg } { return };

         # highlight the sqaure the queen is on
         highlight_square $mode $x $y

         # highlight vertical and horizontal
         for { set i 1 } {$i <= 8} {incr i} {
             highlight_square $mode $x $i
             highlight_square $mode $i $y
         }

         # highlight diagonals
         for { set i 1} { $i <= 8} {incr i} {
             highlight_square $mode [expr $x+$i] [expr $y+$i]
             highlight_square $mode [expr $x-$i] [expr $y-$i]
             highlight_square $mode [expr $x+$i] [expr $y-$i]
             highlight_square $mode [expr $x-$i] [expr $y+$i]
         }
     }
                                                       _# 8-queens.tcl_
     proc disable_next {} {
         .next config -state disabled
     }

     setup_display

     # button for sending a 'next' message
     button .next -text next -command {prolog_event next}
     pack .next

     # button for sending a 'stop' message
     button .stop -text stop -command {prolog_event stop}
     pack .stop


 [image src="images/tcltk8queens.png" text="" ]
            8-Queens Solution, Attacked Squares Highlighted


File: sicstus.info,  Node: Quick Reference,  Next: Resources,  Prev: Putting It All Together,  Up: lib-tcltk

10.39.6 Quick Reference
-----------------------

* Menu:

* Command Format Summary:: Command Format Summary
* Predicates for Prolog to Interact with Tcl Interpreters:: Predicates for Prolog to Interact with Tcl Interpreters
* Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions:: Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions
* Commands for Tcl Interpreters to Interact with The Prolog System:: Commands for Tcl Interpreters to Interact with The Prolog System


File: sicstus.info,  Node: Command Format Summary,  Next: Predicates for Prolog to Interact with Tcl Interpreters,  Up: Quick Reference

10.39.6.1 Command Format Summary
................................

COMMAND        ::= NAME
               | 'codes("code-list")'
               | 'write("term")'
               | 'writeq("term")'
               | 'write_canonical("term")'
               | 'format(FMT,ARGS)'
               | 'dq(COMMAND)'
               | 'br(COMMAND)'
               | 'sqb(COMMAND)'
               | 'min(COMMAND)'
               | 'dot(LISTOFNAMES)'
               | 'list(LISTOFCOMMANDS)'
               | LISTOFCOMMANDS
FMT            ::= "atom"
NAME           ::= "atom"                    { other than '[]' }
               | "number"
LISTOFCOMMANDS ::= '[]'
               | '[ COMMAND |
               LISTOFCOMMANDS ]'
LISTOFNAMES    ::= '[]'
               | '[ NAME | LISTOFNAMES ]'
ARGS           ::= '[]'
               | '[ "term" | ARGS ]'

where

ATOM
NUMBER
     denote their printed representations
'codes(PROLOGSTRING)'
     denotes the string represented by PROLOGSTRING (a code-list)
'write(TERM)'
'writeq(TERM)'
'write_canonical(TERM)'
     denotes the string that is printed by the corresponding built-in
     predicate
'format(FMT, ARGS)'
     denotes the string that is printed by the corresponding built-in
     predicate
'dq(COMMAND)'
     denotes the string specified by COMMAND, enclosed in double quotes
'br(COMMAND)'
     denotes the string specified by COMMAND, enclosed in curly brackets
'sqb(COMMAND)'
     denotes the string specified by COMMAND, enclosed in square
     brackets
'min(COMMAND)'
     denotes the string specified by COMMAND, immediately preceded by a
     hyphen
'dot(LISTOFNAME)'
     denotes the widget path specified by LISTOFNAME, preceded by and
     separated by dots
'list(LISTOFCOMMANDS)'
     denotes the TCL list with one element for each element in
     LISTOFCOMMANDS.
LISTOFCOMMANDS
     denotes the string denoted by each element, separated by spaces


File: sicstus.info,  Node: Predicates for Prolog to Interact with Tcl Interpreters,  Next: Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions,  Prev: Command Format Summary,  Up: Quick Reference

10.39.6.2 Predicates for Prolog to Interact with Tcl Interpreters
.................................................................

'tcl_new(-TCLINTERPRETER)'
     Create a Tcl interpreter and return a handle to it in the variable
     INTERPRETER.

'tcl_delete(+TCLINTERPRETER)'
     Given a handle to a Tcl interpreter in variable TCLINTERPRETER, it
     deletes the interpreter from the system.

'tcl_eval(+TCLINTERP, +COMMAND, -RESULT)'
     Evaluates the Tcl command term given in COMMAND in the Tcl
     interpreter handle provided in TCLINTERPRETER.  The result of the
     evaluation is returned as a string in RESULT.

'tcl_event(+TCLINTERP, +COMMAND, -EVENTS)'
     Evaluates the Tcl command term given in COMMAND in the Tcl
     interpreter handle provided in TCLINTERPRETER.  The first Prolog
     events arising from the evaluation is returned as a list in EVENTS.
     Blocks until there is something on the event queue.


File: sicstus.info,  Node: Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions,  Next: Commands for Tcl Interpreters to Interact with The Prolog System,  Prev: Predicates for Prolog to Interact with Tcl Interpreters,  Up: Quick Reference

10.39.6.3 Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions
....................................................................................

'tk_new(+OPTIONS, -INTERP)'
     Create a Tcl interpreter with Tk extensions.

     OPTIONS should be a list of options described following:

     'top_level_events'
          This allows Tk events to be handled while Prolog is waiting
          for terminal input; for example, while the Prolog system is
          waiting for input at the top-level prompt.  Without this
          option, Tk events are not serviced while the Prolog system is
          waiting for terminal input.

     'name(+APPLICATIONNAME)'
          This gives the main window a title APPLICATIONNAME.  This name
          is also used for communicating between Tcl/Tk applications via
          the Tcl 'send' command.

     'display(+DISPLAY)'
          (This is X windows specific.)  Gives the name of the screen on
          which to create the main window.  If this is not given, then
          the default display is determined by the 'DISPLAY' environment
          variable.

'tk_do_one_event'
'tk_do_one_event(+OPTIONS)'
     Passes control to Tk to handle a single event before passing
     control back to Prolog.  The type of events handled is passed
     through the OPTIONS variable, a list of event types and options.

     The OPTIONS list can contain the following atoms:

     'tk_dont_wait'
          do not wait for new events, process only those that are ready

     'tk_window_events'
          process window events

     'tk_file_events'
          process file events

     'tk_timer_events'
          process timer events

     'tk_idle_events'
          process 'Tcl_DoWhenIdle' events

     'tk_all_events'
          process any event

     Calling 'tk_do_one_event/0' is equivalent to a call to
     'tk_do_one_event/1' with all flags set.  If the 'tk_dont_wait' flag
     is set and there is no event to handle, then the call will fail.

'tk_next_event(+OPTIONS, -EVENT)'
'tk_next_event(+OPTIONS, +TCLINTERPRETER, -EVENT)'
     These predicates are similar to 'tk_do_one_event/[0,1]' except that
     they processes Tk events until is at least one Prolog event
     happens, when they succeed binding EVENT to the first term on the
     Prolog event queue associated with the interpreter TCLINTERPRETER.

'tk_main_loop'
     Pass control to Tk until all windows in all Tcl/Tk interpreters are
     gone.

'tk_main_window(+TCLINTERPRETER, -TKWINDOW)'
     Return in TKWINDOW a reference to the main window of a Tcl/Tk
     interpreter with handle passed in TCLINTERPRETER.

'tk_destroy_window(+TKWINDOW)'
     Destroy a window or widget.

'tk_make_window_exist(+TKWINDOW)'
     Force display of a window or widget.

'tk_num_main_windows(-NUMBEROFWINDOWS)'
     Return in NUMBEROFWINDOWS the total number of Tk main windows
     existing in the system.


File: sicstus.info,  Node: Commands for Tcl Interpreters to Interact with The Prolog System,  Prev: Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions,  Up: Quick Reference

10.39.6.4 Commands for Tcl Interpreters to Interact with The Prolog System
..........................................................................

'prolog'
     Evaluate a Prolog expression from Tcl.

'prolog_event'
     Place a Prolog term on the Prolog event queue from inside Tcl.


File: sicstus.info,  Node: Resources,  Prev: Quick Reference,  Up: lib-tcltk

10.39.7 Resources
-----------------

We do not know of any resources out there specifically for helping with
creating Prolog applications with Tcl/Tk interfaces.  Instead we list
here some resources for Tcl/Tk, which may help readers to build the
Tcl/Tk side of the application.

* Menu:

* Web Sites:: Web Sites
* Books:: Books
* TclTk Manual Pages:: Manual Pages


File: sicstus.info,  Node: Web Sites,  Next: Books,  Up: Resources

10.39.7.1 Web Sites
...................

The home of Tcl/Tk is at:
     <http://tcl.sourceforge.net>

   The Tcl Developer Xchange site is at:
     <http://www.tcl.tk>


File: sicstus.info,  Node: Books,  Next: TclTk Manual Pages,  Prev: Web Sites,  Up: Resources

10.39.7.2 Books
...............

There are a surprising number of books on Tcl/Tk, extensions to Tcl/Tk,
and Tk as an extension to other languages.  Here we mention just a few
of the well-known books that will get you started with building Tcl/Tk
GUIs, which can then be interfaced to your Prolog applications.

   * Brent Welch, 'Practical Programming in Tcl and Tk'.  Prentice Hall,
     1999.  3rd Edition ISBN: 0-13-022028-0
     <http://www.beedub.com/book/>

   * John Ousterhout, 'Tcl and the Tk Toolkit'.  Addison-Wesley, 1994,
     ISBN 0-201-63337-X

   * Paul Raines, 'Tcl/Tk Pocket Reference', 1st Ed., Oct.  1998, ISBN
     1-56592-498-3

   * Paul Raines & Jeff Tranter, 'Tcl/Tk in a Nutshell', 1st Ed., March
     1999, 1-56592-433-9

   Also visit the Tcl/Tk wiki:

     <http://wiki.tcl.tk/>


File: sicstus.info,  Node: TclTk Manual Pages,  Prev: Books,  Up: Resources

10.39.7.3 Manual Pages
......................

Complete manual pages in various formats and for various versions of the
Tcl/Tk library can be found at the Tcl/Tk web site:

     <http://www.tcl.tk/>


File: sicstus.info,  Node: lib-terms,  Next: lib-timeout,  Prev: lib-tcltk,  Up: The Prolog Library

10.40 Term Utilities--'library(terms)'
======================================

This library module provides miscellaneous operations on terms.
Exported predicates:

'subsumeschk(+GENERAL, +SPECIFIC)'

     is true when SPECIFIC is an instance of GENERAL.  It does not bind
     any variables.

     This predicate is identical to the built-in 'subsumes_term/2' and
     it is only present for backwards compatibility.

'subsumes(+GENERAL, +SPECIFIC)'

     is true when SPECIFIC is an instance of GENERAL.  It will bind
     variables in GENERAL (but not those in SPECIFIC, except when
     +GENERAL and +SPECIFIC share variables) so that GENERAL becomes
     identical to SPECIFIC.

     In many cases, binding variable is not really desirable, in which
     case 'subsumes_term/2' should be used instead.  If unification is
     in fact wanted, it may be better to make this explicit in your code
     by using 'subsumes_term/2' followed by an explicit unification,
     e.g. 'subsumes_term(G,S), G=S'.
'variant(+TERM, +VARIANT)'

     is true when TERM and VARIANT are identical modulo renaming of
     variables, provided TERM and VARIANT have no variables in common.
'term_subsumer(+TERM1, +TERM2, -TERM)'

     binds TERM to a most specific generalisation of TERM1 and TERM2.
     Using Plotkin's algorithm [Machine Intelligence 5, 1970], extended
     by Dan Sahlin to handle cyclic structures.
'term_hash(+TERM, -HASH)'

     Equivalent to 'term_hash(Term, [], Hash)'.
'term_hash(+TERM, +OPTIONS, -HASH)'
     OPTIONS is a list of options,

     'algorithm(ALGORITHM)'

          ALGORITHM specifies which hash function to use.  An atom, one
          of,

          'default'

               This is currently the same as 'jenkins'.  This is the
               default.  If we ever see a need to change the default
               hash algorithm again then the algorithm denoted by
               'default' may change but the algorithm denoted by the
               other names, like ''sicstus-4.0.5'', will not change.

          'jenkins'

               Based on the algorithm "lookup3" by Bob Jenkins, see
               <http://burtleburtle.net/bob/hash/doobs.html>.

          'hsieh'

               Based on the algorithm "SuperFastHash" by Paul Hsieh, see
               <http://www.azillionmonkeys.com/qed/hash.html>.  Despite
               the name neither this nor any other choice of algorithm
               significantly affects the speed of 'term_hash/3'.

          'sdbm'

               Based on the well known algorithm "sdbm".

          ''sicstus-4.0.4''

               This is the algorithm used up to SICStus Prolog 4.0.4
               (inclusive).  It is only present to provide backwards
               compatibility.  It is not as good as any of the above
               algorithms.  Note that this atom needs to be quoted.

               This algorithm produces hash values that may differ
               between platforms.

          ''sicstus-4.0.5''

               This is the same as 'jenkins'.  I.e. the default since
               SICStus Prolog 4.0.5.  Note that this atom needs to be
               quoted.

          there are some other (not as good) algorithms available for
          the curious, see the source for detail.

          Unless otherwise noted, the hash value will be identical
          across runs and platforms.

     'range(RANGE)'

          The resulting hash value will be non-negative and less than
          the upper bound specified by RANGE.  RANGE should be either a
          positive integer, or an atom, one of,

          'infinite'

               Do not constrain the hash value.  Currently all hash
               algorithms produce an unsigned 32-bit integer.

          'smallint'

               Ensure the resulting hash value is a small integer.  This
               is the same as specifying a range of '2^28' on 32-bit
               platforms and '2^60' on 64-bit platforms.

          'smallint32'

               Ensure the resulting hash value is in the 32-bit platform
               range of small integers, i.e. the same as a range of
               '2^28'.

          'default'

               The same as 'smallint32'.  This is the default.  This
               ensures that, by default, the same hash value is computed
               for the same term on both 32-bit and 64-bit platforms.

     'depth(DEPTH)'
          Specifies how deep to descend into the term when calculating
          the hash value.  If 'Depth' is a non-negative integer the
          subterms up to depth DEPTH of TERM are used in the
          computation.  Alternatively, if 'Depth' is the atom
          'infinite', all subterms of TERM are relevant in computing
          HASH.  In the latter case TERM must be acyclic.  In this
          context the _depth_ of a term is defined as follows: the
          (principal functor of) the term itself has depth 1, and an
          argument of a term with depth I has depth I+1.  Note that this
          is similar to, but not the same as, the value computed by
          'term_depth/2'.  For legacy reasons a DEPTH of -1 is treated
          the same a 'infinite'.

     'if_var(IFVAR)'

          Specifies what to do if a variable is encountered in the term
          (i.e. to the specified depth).  IFVAR should be an atom, one
          of,

          'error'

               An instantiation error is thrown.

          'ignore'

               The variable is ignored and the hash algorithm continues
               with the other parts of the term.

          'value(Value)'

               The hash algorithm stops, the intermediate hash result is
               discarded and 'Hash' is bound to 'Value'.  There is no
               restrictions on 'Value', it need not be an integer or
               even be ground.
          'default'
               This is the same as 'value(_)', i.e. 'term_hash/3' just
               succeeds without binding 'Hash'.  This is the default.
               This is useful when the hash value us used for
               first-argument indexing.  This ensures that if the
               (possibly variable-valued) hash values for TERM1 and
               TERM2 are HASH1 and HASH2, respectively, then if TERM1
               and TERM2 are unifiable (to the specified depth) then so
               are HASH1 and HASH2.  For other use cases it is probably
               more appropriate to specify 'if_var(error)'.
'term_hash(+TERM, +DEPTH, +RANGE, -HASH)'
     Equivalent to 'term_hash(Term, [depth(DEPTH), range(RANGE)],
     Hash)'.  'term_hash/[2,3,4]' is provided primarily as a tool for
     the construction of sophisticated Prolog clause access schemes.
     Its intended use is to generate hash values for terms that will be
     used with first argument clause indexing, yielding compact and
     efficient multi-argument or deep argument indexing.
'term_variables_set(+TERM, -VARIABLES)   since release 4.3'

     True if VARIABLES is the (ordered) set of variables occurring in
     TERM.

     This was called 'term_variables/2' prior to SICStus Prolog 4.3 but
     now 'term_variables/2' is a built-in with different meaning, due to
     alignment with the ISO Prolog standard.
'term_variables_bag(+TERM, -VARIABLES)'

     True if VARIABLES is the list of variables occurring in TERM, in
     first occurrence order.

     This predicate has been superseeded by the built-in
     'term_variables/2' and it is only present for backwards
     compatibility.

     The name is an historical accident, the result is not really a bag
     (i.e. multiset).
'cyclic_term(+X)'

     True if X is infinite (cyclic).  Runs in linear time.
'term_order(+X, +Y, -R)'

     is true when X and Y are arbitrary terms, and R is '<', '=', or '>'
     according as X @< Y, X == Y, or X @> Y.  This is the same as
     'compare/3', except for the argument order.
'contains_term(+KERNEL, +EXPRESSION)'

     is true when the given KERNEL occurs somewhere in the EXPRESSION.
     It can only be used as a test; to generate sub-terms use
     'sub_term/2'.
'free_of_term(+KERNEL, +EXPRESSION)'

     is true when the given KERNEL does not occur anywhere in the
     EXPRESSION.  NB: if the EXPRESSION contains an unbound variable,
     this must fail, as the KERNEL might occur there.  Since there are
     infinitely many KERNELS not contained in any EXPRESSION, and also
     infinitely many EXPRESSIONS not containing any KERNEL, it doesn't
     make sense to use this except as a test.
'occurrences_of_term(+KERNEL, +EXPRESSION, -TALLY)'

     is true when the given KERNEL occurs exactly TALLY times in
     EXPRESSION.  It can only be used to calculate or test TALLY; to
     enumerate KERNELS you'll have to use 'sub_term/2' and then test
     them with this routine.  If you just want to find out whether
     KERNEL occurs in EXPRESSION or not, use 'contains_term/2' or
     'free_of_term/2'.
'contains_var(+VARIABLE, +TERM)'

     is true when the given TERM contains at least one sub-term which is
     identical to the given VARIABLE.  We use '==' to check for the
     variable ('contains_term/2' uses '=') so it can be used to check
     for arbitrary terms, not just variables.
'free_of_var(+VARIABLE, +TERM)'

     is true when the given TERM contains no sub-term identical to the
     given VARIABLE (which may actually be any term, not just a var).
     For variables, this is precisely the "occurs check" which is needed
     for sound unification.
'occurrences_of_var(+TERM, +VARIABLE, -TALLY)'

     is true when the given VARIABLE occurs exactly TALLY times in TERM.
     It can only be used to calculate or test TALLY; to enumerate
     Variables you'll have to use 'sub_term/2' and then test them with
     this routine.  If you just want to find out whether VARIABLE occurs
     in TERM or not, use 'contains_var/2' or 'free_of_var/2'.
'sub_term(?KERNEL, +TERM)'

     is true when KERNEL is a sub-term of TERM.  It enumerates the
     sub-terms of TERM in an arbitrary order.  Well, it is defined that
     a sub-term of TERM will be enumerated before its own sub-terms are
     (but of course some of those sub-terms might be elsewhere in TERM
     as well).
'depth_bound(+TERM, +BOUND)'

     is true when the term depth of TERM is no greater than BOUND, that
     is, when constructor functions are nested no more than BOUND deep.
     Later variable bindings may invalidate this bound.	 To find the
     (current) depth, use 'term_depth/2'.
'length_bound(?LIST, +BOUND)'

     is true when the length of LIST is no greater than BOUND.  It can
     be used to enumerate Lists up to the bound.
'size_bound(+TERM, +BOUND)'

     is true when the number of constant and function symbols in TERM is
     (currently) at most BOUND.  If TERM is non-ground, later variable
     bindings may invalidate this bound.	 To find the (current) size,
     use 'term_size/2'.
'term_depth(+TERM, -DEPTH)'

     calculates the Depth of a Term, using the definition
          term_depth(Var) = 0
          term_depth(Const) = 0
          term_depth(F(T1,...,Tn)) = 1+max(term_depth(T1),...,term_depth(Tn))
     Could be defined as:

          term_depth(X, Depth) :-
          simple(X), !, Depth = 0.
          term_depth(X, Depth) :-
          (   foreacharg(A,X),
          fromto(0,D0,D,Depth0)
          do  term_depth(A, D1),
          D is max(D0,D1)
          ),
          Depth is Depth0+1.
'term_size(+TERM, -SIZE)'

     calculates the SIZE of a TERM, defined to be the number of constant
     and function symbol occurrences in it.  Could be defined as:

          term_size(X, Size) :-
          var(X), !, Size = 0.
          term_size(X, Size) :-
          simple(X), !, Size = 1.
          term_size(X, Size) :-
          (   foreacharg(A,X),
          fromto(1,S0,S,Size)
          do  term_size(A, S1),
          S is S0+S1
          ).
'same_functor(?T1, ?T2)'

     is true when T1 and T2 have the same principal functor.	 If one of
     the terms is a variable, it will be instantiated to a new term with
     the same principal functor as the other term (which should be
     instantiated) and with arguments being new distinct variables.  If
     both terms are variables, an error is reported.
'same_functor(?T1, ?T2, ?N)'
     is true when T1 and T2 have the same principal functor, and their
     common arity is N.  Like 'same_functor/3', at least one of T1 and
     T2 must be bound, or an error will be reported.
'same_functor(?T1, ?T2, ?F, ?N)'
     is true when T1 and T2 have the same principal functor, and their
     common functor is F/N.  Given T1 (or T2) the remaining arguments
     can be computed.  Given F and N, the remaining arguments can be
     computed.  If too many arguments are unbound, an error is reported.


File: sicstus.info,  Node: lib-timeout,  Next: lib-trees,  Prev: lib-terms,  Up: The Prolog Library

10.41 Meta-Call with Limit on Execution Time--'library(timeout)'
================================================================

This module contains utilities for computing a goal with limit on
execution time.

   As of release 4.4, this library no longer uses a foreign resource,
and it can be used by more than one SICStus instance in the same
process.

   Exported predicates:

'time_out(:GOAL, +TIME, -RESULT)'

     The GOAL is executed as if by 'call/1'.  If computing any solution
     takes more than TIME milliseconds, the goal will be aborted, as if
     by 'throw/1', and RESULT unified with the atom 'time_out'.  If the
     goal succeeds within the specified time, RESULT is unified with the
     atom 'success'.  TIME must be a positive integer, less than
     2147483647.

     Currently, time is measured in runtime (as opposed to walltime),
     i.e. the time does not increment while the program is waiting, e.g.
     during a blocking read.

     Ideally, the measured runtime should be thread-specific, i.e. it
     should not be affected by computations done in other threads in the
     process (of course, thread-specific time is the same as process
     runtime for a single-threaded process).  Thread-specific runtime
     measurement is only implemented on Windows.

     The precision of the timeout interval is usually not better than
     several tens of milliseconds.  This is due to limitations in the
     timing mechanisms used to implement 'library(timeout)'.


File: sicstus.info,  Node: lib-trees,  Next: lib-types,  Prev: lib-timeout,  Up: The Prolog Library

10.42 Updatable Binary Trees--'library(trees)'
==============================================

This libary module provides updatable binary trees with logarithmic
access time.  Exported predicates:

'gen_label(?INDEX, +TREE, ?VALUE)'

     assumes that Tree is a proper binary tree, and is true when VALUE
     is the INDEX-TH element in TREE.  Can be used to enumerate all
     VALUES by ascending INDEX.
'get_label(+INDEX, +TREE, -LABEL)'

     treats the tree as an array of N elements and returns the INDEX-TH.
     If INDEX < 1 or > N it simply fails, there is no such element.  As
     Tree need not be fully instantiated, and is potentially unbounded,
     we cannot enumerate INDICES.
'list_to_tree(+LIST, -TREE)'

     takes a given proper LIST of N elements and constructs a binary
     TREE where 'get_label(K, TREE, LAB)' <=> LAB is the KTH element of
     LIST.
'map_tree(:PRED, +OLDTREE, ?NEWTREE)'

     is true when OLDTREE and NEWTREE are binary trees of the same shape
     and PRED(OLD,NEW) is true for corresponding elements of the two
     trees.
'put_label(+INDEX, +OLDTREE, -LABEL, -NEWTREE)'

     constructs a new tree the same shape as the old which moreover has
     the same elements except that the INDEX-TH one is LABEL.  Unlike
     the "arrays" of 'library(arrays)', OLDTREE is not modified and you
     can hang on to it as long as you please.  Note that O(LG N) new
     space is needed.
'put_label(+INDEX, +OLDTREE, -OLDLABEL, -NEWTREE, +NEWLABEL)'
     is true when OLDTREE and NEWTREE are trees of the same shape having
     the same elements except that the INDEX-TH element of OLDTREE is
     OLDLABEL and the INDEX-TH element of NEWTREE is NEWLABEL.  You can
     swap the <TREE,LABEL> argument pairs if you like, it makes no
     difference.
'tree_size(+TREE, -SIZE)'

     calculates the number of elements in the TREE.  All trees made by
     'list_to_tree/2' that are the same size have the same shape.
'tree_to_list(+TREE, -LIST)'

     is the converse operation to 'list_to_tree/2'.  Any mapping or
     checking operation can be done by converting the tree to a list,
     mapping or checking the list, and converting the result, if any,
     back to a tree.  It is also easier for a human to read a list than
     a tree, as the order in the tree goes all over the place.


File: sicstus.info,  Node: lib-types,  Next: lib-ugraphs,  Prev: lib-trees,  Up: The Prolog Library

10.43 Type Checking--'library(types)'
=====================================

This library module provides more and better type tests.  For the
purposes of this library, we first define an abstract type TYPETERM, as
follows:

TYPETERM           ::= 'atom'
                   | 'atomic'
                   | 'boolean'
                   | 'callable'
                   | 'character'
                   | 'character_code'
                   | 'compound'
                   | 'db_reference'
                   | 'float'
                   | 'float(RANGETERM)'
                   | 'ground'
                   | 'integer'
                   | 'integer(RANGETERM)'
                   | 'list'
                   | 'list(TYPE)'
                   | 'mutable'
                   | 'nonvar'
                   | 'number'
                   | 'number(RANGETERM)'
                   | 'oneof(L)'
                   | 'order'
                   | 'pair'
                   | 'pred_spec'
                   | 'pred_spec_tree'
                   | 'proper_list'
                   | 'proper_list(TYPE)'
                   | 'simple'
                   | 'term'
                   | 'var'
                   | 'var_or(TYPE)'
RANGETERM          ::= 'between(L,U)'
                   | '>=(L)'
                   | '>(L)'
                   | '<(L)'
                   | '=<(L)'
                   | '=:=(L)'
                   | '=\=(L)'

   Culprit information:

   These predicates takes arguments that are used when reporting the
reason and location of errors.  The arguments are:
GOAL
     must be a callable term, without '(:)/2' module wrapping, with
     arity at least ARGNO.
ARGNO
     must be a non-negative integer, where zero means no specific
     argument postition.
CULPRIT
     the term that has the offending value.

   Exported predicates:

'must_be(+TERM, +TYPE, +GOAL, +ARGNO)'

     checks whether the TERM belongs to the indicated TYPE, which should
     be a TYPETERM.  If it doesn't, several different error exceptions
     can be thrown: the TERM may not be instantiated enough to tell yet
     (Instantiation Error); it may be instantiated when an unbound
     variable was expected (Uninstantiation Error); it may be definitely
     not of the right type (Type Error); it may be of the right type but
     not representable (Representation Error); or it may be of the right
     type but in the wrong domain (Domain Error).  If an error exception
     is thrown, it will include GOAL and ARGNO and, if possible, the
     line of code in the scope of which the error occurred.  *Note
     ref-ere-err::.

'illarg(+ERRORTERM, +GOAL, +ARGNO)'
'illarg(+ERRORTERM, +GOAL, +ARGNO, +CULPRIT)'

     is the way to raise an error exception, if you would like the
     exception to pinpoint the line of code in the scope of which the
     error occurs.  This is especially useful in the context of
     source-linked debugging.  CULPRIT defaults to argument number ARGNO
     of GOAL.  These three arguments are passed to the exception being
     raised, if appropriate.  ERRORTERM should be one of the following.
     *Note ref-ere-err::.

     'var'
          An Instantiation error is raised.

     'type(ERRORTYPE)'
          Same as 'must_be(CULPRIT, ERRORTYPE, GOAL, ARGNO)'.

     'domain(ERRORTYPE,ERRORDOMAIN)'
          First, the type is checked by 'must_be(CULPRIT, ERRORTYPE,
          GOAL, ARGNO)'.  If the type is valid, a Domain Error is raised
          with the expected domain being ERRORDOMAIN.

     'force_type(EXPTYPE)'
          A Type Error is raised.

     'context(CONTEXTTYPE,COMMANDTYPE)'
          A Context Error is raised.

     'existence(OBJTYPE,CULPRIT,MESSAGE)'
          An Existence Error is raised.

     'permission(OPERATION,OBJTYPE,MESSAGE)'
          A Permission Error is raised.

     'representation(ERRORTYPE)'
          A Representation Error is raised.

     'evaluation(ERRORTYPE)'
          An Evaluation Error is raised.

     'consistency(CULPRIT1,CULPRIT2,MESSAGE)'
          A Consistency Error is raised.

     'syntax(POS,MSG,TOKENS,AFTERERROR)'
          A Syntax Error is raised.

     'resource(RESOURCE)'
          A Resource Error is raised.

     'system(MESSAGE)'
          A System Error is raised.


File: sicstus.info,  Node: lib-ugraphs,  Next: lib-varnumbers,  Prev: lib-types,  Up: The Prolog Library

10.44 Unweighted Graph Operations--'library(ugraphs)'
=====================================================

This library module provides operations on directed graphs.  An
unweighted directed graph (ugraph) is represented as a list of
(VERTEX-NEIGHBORS) pairs, where the pairs are in standard order (as
produced by 'keysort/2' with unique keys) and the neighbors of each
vertex are also in standard order (as produced by 'sort/2'), and every
neighbor appears as a vertex even if it has no neighbors itself.

   An undirected graph is represented as a directed graph where for each
edge (U,V) there is a symmetric edge (V,U).

   An edge (U,V) is represented as the term U-V.

   A vertex can be any term.  Two vertices are distinct iff they are not
identical ('==').

   A path is represented as a list of vertices.  No vertex can appear
twice in a path.

   Exported predicates:

'vertices_edges_to_ugraph(+VERTICES, +EDGES, -GRAPH)'

     is true if VERTICES is a proper list of vertices, EDGES is a proper
     list of edges, and GRAPH is a graph built from VERTICES and EDGES.
     VERTICES and EDGES may be in any order.  The vertices mentioned in
     EDGES do not have to occur explicitly in VERTICES.  VERTICES may be
     used to specify vertices that are not connected to any edges.
'vertices(+GRAPH, -VERTICES)'

     unifies VERTICES with the vertices in GRAPH.  Could be defined as:

          vertices(Graph, Vertices) :-
          	(   foreach(V-_,Graph),
          	    foreach(V,Vertices)
          	do  true
          	).
'edges(+GRAPH, -EDGES)'

     unifies EDGES with the edges in GRAPH.  Could be defined as:

          edges(Graph, Edges) :-
          	(   foreach(V1-Neibs,Graph),
          	    fromto(Edges,S0,S,[])
          	do  (   foreach(V2,Neibs),
          		param(V1),
          		fromto(S0,[V1-V2|S1],S1,S)
          	    do  true
          	    )
          	).
'add_vertices(+GRAPH1, +VERTICES, -GRAPH2)'

     is true if GRAPH2 is GRAPH1 with VERTICES added to it.
'del_vertices(+GRAPH1, +VERTICES, -GRAPH2)'

     is true if GRAPH2 is GRAPH1 with VERTICES and all edges to and from
     VERTICES removed from it.
'add_edges(+GRAPH1, +EDGES, -GRAPH2)'

     is true if GRAPH2 is GRAPH1 with EDGES and their "to" and "from"
     vertices added to it.
'del_edges(+GRAPH1, +EDGES, -GRAPH2)'

     is true if GRAPH2 is GRAPH1 with EDGES removed from it.
'transpose_ugraph(+GRAPH, -TRANSPOSE)'

     is true if TRANSPOSE is the graph computed by replacing each edge
     (U,V) in GRAPH by its symmetric edge (V,U).  It can only be used
     one way around.  The cost is O(N LOG N).
'neighbors(+VERTEX, +GRAPH, -NEIGHBORS)'
'neighbours(+VERTEX, +GRAPH, -NEIGHBORS)'

     is true if VERTEX is a vertex in GRAPH and NEIGHBORS are its
     neighbors.
'complement(+GRAPH, -COMPLEMENT)'

     COMPLEMENT is the complement graph of GRAPH, i.e.  the graph that
     has the same vertices as GRAPH but only the edges that are not in
     GRAPH.
'compose(+G1, +G2, -COMPOSITION)'

     computes COMPOSITION as the composition of two graphs, which need
     not have the same set of vertices.
'transitive_closure(+GRAPH, -CLOSURE)'

     computes CLOSURE as the transitive closure of GRAPH in O(N^3) time.
'transitive_reduction(+GRAPH, -REDUCTION)   since release 4.3.3'

     computes REDUCTION as the transitive reduction of GRAPH.

     Aho et al.  let GRAPHT be the transitive closure of GRAPH.  Then an
     edge UV belongs to the transitive reduction iff UV belongs to GRAPH
     but not to the composition of GRAPH and GRAPHT.  In this
     construction, the edges of the composition represent pairs of
     vertices connected by paths of length two or more.
'symmetric_closure(+GRAPH, -CLOSURE)'

     computes CLOSURE as the symmetric closure of GRAPH, i.e.  for each
     edge (U,V) in GRAPH, add its symmetric edge (V,U).  Approx.  O(N
     LOG N) time.  This is useful for making a directed graph
     undirected.  Could be defined as:

          symmetric_closure(Graph, Closure) :-
          	transpose_ugraph(Graph, Transpose),
          	(   foreach(V-Neibs1,Graph),
          	    foreach(V-Neibs2,Transpose),
          	    foreach(V-Neibs,Closure)
          	do  ord_union(Neibs1, Neibs2, Neibs)
          	).
'top_sort(+GRAPH, -SORTED)'

     finds a topological ordering of GRAPH and returns the ordering as a
     list of SORTED vertices.  Fails iff no ordering exists, i.e.  iff
     the graph contains cycles.  Approx.  O(N LOG N) time.
'max_path(+V1, +V2, +GRAPH, -PATH, -COST)'

     is true if PATH is a list of vertices constituting a longest path
     of cost COST from V1 to V2 in GRAPH, there being no cyclic paths
     from V1 to V2.  Takes O(N^2) time.
'min_path(+V1, +V2, +GRAPH, -PATH, -LENGTH)'

     is true if PATH is a list of vertices constituting a shortest path
     of length LENGTH from V1 to V2 in GRAPH.  Takes O(N^2) time.
'min_paths(+VERTEX, +GRAPH, -TREE)'

     is true if TREE is a tree of all the shortest paths from VERTEX to
     every other vertex in GRAPH.  This is the single-source shortest
     paths problem.  The algorithm is straightforward.
'path(+VERTEX, +GRAPH, -PATH)'

     is given a GRAPH and a VERTEX of that GRAPH, and returns a maximal
     PATH rooted at VERTEX, enumerating more PATHS on backtracking.
'reduce(+GRAPH, -REDUCED)'

     is true if REDUCED is the reduced graph for GRAPH.  The vertices of
     the reduced graph are the strongly connected components of GRAPH.
     There is an edge in REDUCED from U to V iff there is an edge in
     GRAPH from one of the vertices in U to one of the vertices in V.  A
     strongly connected component is a maximal set of vertices where
     each vertex has a path to every other vertex.  Algorithm from
     "Algorithms" by Sedgewick, page 482, Tarjan's algorithm.
'reachable(+VERTEX, +GRAPH, -REACHABLE)'

     is given a Graph and a VERTEX of that GRAPH, and returns the set of
     vertices that are REACHABLE from that VERTEX.  Takes O(N^2) time.
'random_ugraph(+P, +N, -GRAPH)'

     where P is a probability, unifies GRAPH with a random graph of N
     vertices where each possible edge is included with probability P.
'min_tree(+GRAPH, -TREE, -COST)'

     is true if TREE is a spanning tree of an _undirected_ GRAPH with
     cost COST, if it exists.  Using a version of Prim's algorithm.
'max_cliques(+GRAPH, -CLIQUES)   since release 4.3.3'

     is true if CLIQUES is the set of the maximal cliques of the
     _undirected_ graph GRAPH.  That is, all subsets of vertices such
     that (i) each pair of vertices in any listed subset is connected by
     an edge, and (ii) no listed subset can have any additional vertex
     added to it.  Using a version of the Bron-Kerbosch algorithm.


File: sicstus.info,  Node: lib-varnumbers,  Next: lib-wgraphs,  Prev: lib-ugraphs,  Up: The Prolog Library

10.45 An Inverse of numbervars/3--'library(varnumbers)'
=======================================================

The built-in predicate 'numbervars/3' makes a term ground by binding the
variables in it to subterms of the form ''$VAR'(N)' where N is an
integer.  Most of the calls to 'numbervars/3' look like
         numbervars(Term, 0, _)
   which can be abbreviated to
         numbervars(Term)
   if you use this package.

   'varnumbers/3' is a partial inverse to 'numbervars/3':
         varnumbers(Term, N0, Copy)
   unifies COPY with a copy of TERM in which subterms of the form
''$VAR'(N)' where N is an integer not less than N0 (that is, subterms
which might have been introduced by 'numbervars/3' with second argument
N0) have been consistently replaced by new variables.  Since 0 is the
usual second argument of 'numbervars/3', there is also
         varnumbers(Term, Copy)

   This provides a facility whereby a Prolog-like data base can be kept
as a term.  For example, we might represent 'append/3' thus:
         Clauses = [
             (append([], '$VAR'(0), '$VAR'(0)) :- true),
             (append(['$VAR'(0)|'$VAR'(1), '$VAR'(2), ['$VAR'(0)|'$VAR(3)]) :-
                 append('$VAR'(1), '$VAR'(2), '$VAR'(3)))
         ]
   and we might access clauses from it by doing
         prove(Goal, Clauses) :-
                 member(Clause, Clauses),
                 varnumbers(Clause, (Goal:-Body)),
                 prove(Goal).

   Exported predicates:

'numbervars(+TERM)'

     makes TERM ground by binding variables to subterms ''$VAR'(N)' with
     values of N ranging from 0 up.
'varnumbers(+TERM, -COPY)'

     xo succeeds when TERM was a term producing by calling
     'numbervars(TERM)' and COPY is a copy of TERM with such subterms
     replaced by variables.
'varnumbers(+TERM, +N0, -COPY)'
     succeeds when TERM was a term produced by calling 'numbervars(TERM,
     N0, N)' (so that all subterms ''$VAR'(X)' have 'integer(X)', 'X >=
     N0') and COPY is a copy of TERM with such subterms replaced by
     variables.


File: sicstus.info,  Node: lib-wgraphs,  Next: lib-xml,  Prev: lib-varnumbers,  Up: The Prolog Library

10.46 Weighted Graph Operations--'library(wgraphs)'
===================================================

This library module provides operations on weighted directed graphs.  A
weighted directed graph (wgraph) is represented as a list of
(VERTEX-EDGELIST) pairs, where the pairs are in standard order (as
produced by 'keysort/2' with unique keys), the edgelist is a list of
(NEIGHBOR-WEIGHT) pair also in standard order (as produced by
'keysort/2' with unique keys), every weight is a nonnegative integer,
and every neighbor appears as a vertex even if it has no neighbors
itself.

   An undirected graph is represented as a directed graph where for each
edge (U,V) there is a symmetric edge (V,U).

   An edge (U,V) is represented as the term U-V.

   A vertex can be any term.  Two vertices are distinct iff they are not
identical ('==').

   A path is represented as a list of vertices.  No vertex can appear
twice in a path.

   Exported predicates:

'vertices/2'
'edges/2'
'add_vertices/3'
'neighbors/3'
'neighbours/3'

     Re-exported from 'library(wgraphs)'.
'wgraph_to_ugraph(+WEIGHTEDGRAPH, -GRAPH)'

     is true if GRAPH has the same vertices and edges as WEIGHTEDGRAPH,
     except the edges of GRAPH are unweighted.  Could be defined as:

          wgraph_to_ugraph(WGraph, Graph) :-
          	(   foreach(V-WNeibs,WGraph),
          	    foreach(V-Neibs,Graph)
          	do  (   foreach(V1-_,WNeibs),
          		foreach(V1,Neibs)
          	    do  true
          	    )
          	).
'ugraph_to_wgraph(+GRAPH, -WEIGHTEDGRAPH)'

     is true if WEIGHTEDGRAPH has the same vertices and edges as GRAPH,
     except the edges of WEIGHTEDGRAPH all have weight 1.  Could be
     defined as:

          ugraph_to_wgraph(Graph, WGraph) :-
          	(   foreach(V-Neibs,Graph),
          	    foreach(V-WNeibs,WGraph)
          	do  (   foreach(V1,Neibs),
          	        foreach(V1-1,WNeibs)
          	    do  true
          	    )
          	).
'ugraph_to_wgraph(+SubGraph, +WeightedGraph, -WeightedSubGraph)'

     is true if WeightedSubGraph has the same vertices and edges as
     SubGraph and the same weights as the corresponding edges in
     WeightedGraph.
'vertices_edges_to_wgraph(+VERTICES, +EDGES, -WEIGHTEDGRAPH)'

     is true if VERTICES is a proper list of vertices, EDGES is a proper
     list of edges, and WEIGHTEDGRAPH is a graph built from VERTICES and
     EDGES.  VERTICES and EDGES may be in any order.  The vertices
     mentioned in EDGES do not have to occur explicitly in VERTICES.
     VERTICES may be used to specify vertices that are not connected to
     any edges.
'del_vertices(+WEIGHTEDGRAPH1, +VERTICES, -WEIGHTEDGRAPH2)'

     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with VERTICES and all
     edges to and from VERTICES removed from it.
'add_edges(+WEIGHTEDGRAPH1, +EDGES, -WEIGHTEDGRAPH2)'

     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with EDGES and their
     "to" and "from" vertices added to it.
'del_edges(+WEIGHTEDGRAPH1, +EDGES, -WEIGHTEDGRAPH2)'

     is true if WEIGHTEDGRAPH2 is WEIGHTEDGRAPH1 with EDGES removed from
     it.
'transpose_wgraph(+WEIGHTEDGRAPH, -TRANSPOSE)'

     is true if TRANSPOSE is the graph computed by replacing each edge
     (U,V) in WEIGHTEDGRAPH by its symmetric edge (V,U).  It can only be
     used one way around.  The cost is O(N LOG N).
'transitive_closure(+WEIGHTEDGRAPH, -CLOSURE)'

     computes Closure as the transitive closure of WEIGHTEDGRAPH in
     O(N^3) time.  Uses Floyd's algorithm and fragments of Barney Pell's
     code.
'symmetric_closure(+WEIGHTEDGRAPH, -CLOSURE)'

     computes CLOSURE as the symmetric closure of WEIGHTEDGRAPH, i.e.
     for each edge (U,V) in WEIGHTEDGRAPH, add its symmetric edge (V,U).
     Approx O(N LOG N) time.  This is useful for making a directed graph
     undirected.
'top_sort(+GRAPH, -SORTED)'

     finds a topological ordering of a GRAPH and returns the ordering as
     a list of SORTED vertices.  Fails iff no ordering exists, i.e.  iff
     the graph contains cycles.  Takes O(N LOG N) time.
'max_path(+V1, +V2, +WEIGHTEDGRAPH, -PATH, -COST)'

     is true if PATH is a list of vertices constituting a longest path
     of cost Cost from V1 to V2 in WEIGHTEDGRAPH, there being no cyclic
     paths from V1 to V2.  Takes O(N^2) time.
'min_path(+V1, +V2, +WEIGHTEDGRAPH, -PATH, -COST)'

     is true if PATH is a list of vertices constituting a shortest path
     with total cost COST from V1 to V2 in WEIGHTEDGRAPH.  Takes O(N^2)
     time.
'min_paths(+VERTEX, +WEIGHTEDGRAPH, -TREE)'

     is true if TREE is a tree of all the shortest paths from VERTEX to
     every other vertex in WEIGHTEDGRAPH.  This is the single-source
     shortest paths problem.  Using Dijkstra's algorithm.
'path(+VERTEX, +WEIGHTEDGRAPH, -PATH)'

     is given a WEIGHTEDGRAPH and a VERTEX of that WEIGHTEDGRAPH, and
     returns a maximal PATH rooted at VERTEX, enumerating more PATHS on
     backtracking.
'reduce(+WEIGHTEDGRAPH, -REDUCED)'

     is true if REDUCED is the reduced graph for WEIGHTEDGRAPH.  The
     vertices of the reduced graph are the strongly connected components
     of WEIGHTEDGRAPH.  There is an edge in REDUCED from U to V iff
     there is an edge in WEIGHTEDGRAPH from one of the vertices in U to
     one of the vertices in V.  A strongly connected component is a
     maximal set of vertices where each vertex has a path to every other
     vertex.  Algorithm from "Algorithms" by Sedgewick, page 482,
     Tarjan's algorithm.
'reachable(+VERTEX, +WEIGHTEDGRAPH, -REACHABLE)'

     is given a WEIGHTEDGRAPH and a VERTEX of that WEIGHTEDGRAPH, and
     returns the set of vertices that are REACHABLE from that VERTEX.
     Takes O(N^2) time.
'random_wgraph(+P, +N, +W, -WEIGHTEDGRAPH)'

     where P is a probability, unifies WEIGHTEDGRAPH with a random graph
     with vertices 1..N where each possible edge is included with
     probability P and random weight in 1..W.
'min_tree(+WEIGHTEDGRAPH, -TREE, -COST)'

     is true if TREE is a minimum-COST spanning tree of an _undirected_
     WEIGHTEDGRAPH with cost COST, if it exists.  Using Kruskal's
     algorithm.


File: sicstus.info,  Node: lib-xml,  Next: lib-zinc,  Prev: lib-wgraphs,  Up: The Prolog Library

10.47 Parsing and Generating XML--'library(xml)'
================================================

This is a package for parsing XML with Prolog, which provides Prolog
applications with a simple "Document Value Model" interface to XML
documents.  A description of the subset of XML that it supports can be
found at: <http://www.binding-time.co.uk/xmlpl.html>

   The package, originally written by Binding Time Ltd., is in the
public domain and unsupported.  To use the package, enter the query:

     | ?- use_module(library(xml)).

   The package represents XML documents by the abstract data type
DOCUMENT, which is defined by the following grammar:

DOCUMENT       ::=                    { well-formed document }
               'xml(ATTRIBUTES,CONTENT)'
               |                      { malformed document }
               'malformed(ATTRIBUTES,CONTENT)'
ATTRIBUTES     ::= '[]'
               |
               '[NAME=CHAR-DATA|ATTRIBUTES]'
CONTENT        ::= '[]'
               | '[CTERM|CONTENT]'
CTERM          ::=                    { text }
               'pcdata(CHAR-DATA)'
               |                      { an XML comment }
               'comment(CHAR-DATA)'
               |                      { a Namespace }
               'namespace(URI,PREFIX,ELEMENT)'
               |                      { <TAG>..</TAG> encloses CONTENT
               'element(TAG,ATTRIBUTES,CONTENT)'or <TAG /> if empty }
               |                      { A PI <?  NAME CHAR-DATA ?> }
               'instructions(NAME,CHAR-DATA)'
               | 'cdata(CHAR-DATA)'   { <![CDATA[CHAR-DATA]]> }
               |                      { DTD <!DOCTYPE ..  > }
               'doctype(TAG,DOCTYPE-ID)'
               |                      { text that hasn't been parsed }
               'unparsed(CHAR-DATA)'
               |                      { TAG is not closed }
               'out_of_context(TAG)'
TAG            ::= "atom"             { naming an element }
NAME           ::= "atom"             { not naming an element }
URI            ::= "atom"             { giving the URI of a namespace }
CHAR-DATA      ::= "code-list"
DOCTYPE-ID     ::=
               'public(CHAR-DATA,CHAR-DATA)'
               |
               'public(CHAR-DATA,DTD-LITERALS)'
               |
               'system(CHAR-DATA)'
               |
               'system(CHAR-DATA,DTD-LITERALS)'
               | 'local'
               |
               'local,DTD-LITERALS'
DTD-LITERALS   ::= '[]'
               |
               '[dtd_literal(CHAR-DATA)|DTD-LITERALS]'

   The following predicates are exported by the package:

'xml_parse(?CHARS, ?DOCUMENT)'
'xml_parse(?CHARS, ?DOCUMENT, +OPTIONS)'

     Either parses CHARS, a "code-list", to DOCUMENT, a DOCUMENT.  CHARS
     is not required to represent strictly well-formed XML. Or generates
     CHARS, a "code-list", from DOCUMENT, a DOCUMENT.  If DOCUMENT is
     not a valid DOCUMENT term representing well-formed XML, an
     exception is raised.  In the second usage of the predicate, the
     only option available is 'format/1'.

     OPTIONS is a list of zero or more of the following, where BOOLEAN
     must be 'true' or 'false':

     'format(BOOLEAN)'
          Indent the element content (default 'true').

     'extended_characters(BOOLEAN)'
          Use the extended character entities for XHTML (default
          'true').

     'remove_attribute_prefixes(BOOLEAN)'
          Remove namespace prefixes from attributes when it's the same
          as the prefix of the parent element (default 'false').

'xml_subterm(+TERM, ?SUBTERM)'

     Unifies SUBTERM with a sub-term of TERM, a DOCUMENT.  This can be
     especially useful when trying to test or retrieve a deeply-nested
     subterm from a document.

'xml_pp(+DOCUMENT)'

     "Pretty prints" DOCUMENT, a DOCUMENT, on the current output stream.


File: sicstus.info,  Node: lib-zinc,  Prev: lib-xml,  Up: The Prolog Library

10.48 Zinc Interface--'library(zinc)'
=====================================

* Menu:

* Zinc Notes:: Notes
* FlatZinc:: FlatZinc
* MiniZinc:: MiniZinc
* Zinc Errors:: Zinc Errors

NICTA (National ICT Australia) develops three languages for specifying
combinatorial (optimization) problems: a high-level modeling language
called "Zinc", a medium-level modeling language called "MiniZinc", and a
low-level solver input language called "FlatZinc".  See
<http://www.minizinc.org> for more information.

   This library provides an interpreter for FlatZinc programs (*note
FlatZinc::), and, via an external MiniZinc-to-FlatZinc translator, an
interpreter also for MiniZinc programs (*note MiniZinc::).  The library
interface was inspired by the MiniZinc and FlatZinc libraries of "The
ECLiPSe Constraint Programming System".  It is compatible with MiniZinc
2.1 distribution.


File: sicstus.info,  Node: Zinc Notes,  Next: FlatZinc,  Up: lib-zinc

10.48.1 Notes
-------------

_Domain variables_
     Only variables with finite integer domains are supported.  This
     includes boolean variables, which are considered finite integer
     domain variables with the domain '0..1'.  Domain variables declared
     to be of type 'var int' are initially given the finite integer
     domain 'inf..sup', and are given maximally wide bounded domains
     before any search is performed on them, as well as before certain
     constraints that demand bounded domains are posted on them.

_Ground set values_
     Although set "variables" are not supported, ground set "values"
     are.  For example, the MiniZinc global constraint 'sum_pred/4'
     takes as second argument an array of such ground set values.

_Solve annotations_

        * The solve annotations currently recognized are 'bool_search',
          'int_search', and 'seq_search'.

        * The FlatZinc specification describes several _exploration
          strategies_.  Currently, the only recognized exploration
          strategies are 'complete' and 'fail'.

        * Variables not included in any solve or 'var_is_introduced'
          annotation are labeled with a default first-fail domain
          splitting heuristic.  This corresponds to 'labeling/2' of
          'library(clpfd)' with the option list '[ff,bisect]'.

        * The choice method 'indomain_random' as described in the FlatZinc
          specification uses 'random_member/2' of 'library(random)'.
          The random generator of SICStus is initialized using the same
          seed on each start up, meaning that the same sequence will be
          tried for 'indomain_random' on each start up.  This behavior
          can be changed by setting a different random seed using
          'setrand/1' of 'library(random)'.

_Constraint annotations_
     Constraint annotations of the form 'domain', 'bounds', and 'value'
     are recognized in relevant FlatZinc-to-'library(clpfd)' constraint
     translations.  Any other constraint annotation is ignored.

_Variable annotations_
     The following variable annotations are recognized.  Any other
     variable annotation is ignored:

     'output_var   since release 4.2'
          the variable may be written on the current output stream.

     'output_array   since release 4.2'
          the variable array may be written on the current output
          stream.

     'var_is_introduced'
          the variable will not be considered in any default labeling
          (such as when the search annotations do not include all
          variables)


File: sicstus.info,  Node: FlatZinc,  Next: MiniZinc,  Prev: Zinc Notes,  Up: lib-zinc

10.48.2 FlatZinc
----------------

* Menu:

* FlatZinc Exported Predicates:: Exported Predicates

The FlatZinc interpreter described here is based on _"Specification of
FlatZinc, version 1.6"_, available at
<http://www.minizinc.org/specifications.html>.

   A FlatZinc program can be run directly using 'fzn_run_file/[1,2]' and
'fzn_run_stream/[1,2]', as well as with 'spfz', a simple command-line
tool interface to 'fzn_run_file/[1,2]' (for details, *note too-spfz::).
For example, a program for solving the 4 Queens problem, located in
'library('zinc/examples/queen4.fzn')', can be run by the following goal:

     | ?- fzn_run_file(library('zinc/examples/queen4')).

or command:

     % spfz $SP_LIBRARY_DIR/zinc/examples/queen4

   The following solution is then written on the current output stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------
   Note the ten consecutive dashes after the solution.

   The following goal can be used to find all solutions:
     | ?- fzn_run_file(library('zinc/examples/queen4'), [solutions(all)]).

or command:

     % spfz $SP_LIBRARY_DIR/zinc/examples/queen4 -a

   The following solutions are then written on the current output
stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------
     q = array1d(1..4, [3, 1, 4, 2]);
     ----------
     ==========
   Note the ten consecutive equal signs after all solutions have been
found.

   FlatZinc programs are not intended to be written (or read) by humans,
but rather to be automatically generated.  One way to generate a FlatZinc
program is by using a MiniZinc-to-FlatZinc translator, such as
'mzn2fzn', bundles with the MiniZinc distribution.  One use of this
translator is to first generate a FlatZinc program from a MiniZinc
program, e.g. by the following command line ('queen.mzn' and
'queen4.dat' can be found in 'library('zinc/examples')'):
     mzn2fzn -G sicstus --data queen4.dat --output-to-file queen4.fzn queen.mzn
   The resulting FlatZinc program 'queen4.fzn' can then be run as
described above.  If a generated FlatZinc program is not desired, then
another use of 'mzn2fzn' is to pipe its result directly to a SICStus
process, e.g. by the following command:

     mzn2fzn -G sicstus --data queen4.dat --output-to-stdout queen.mzn | sicstus --goal 'use_module(library(zinc)), fzn_run_stream(user_input), halt.'

or, simpler:

     minizinc -G sicstus --data queen4.dat queen.mzn -f spfz

or, even simpler:

     minizinc -G sicstus -D n=4 queen.mzn -f spfz

or, simpler still:

     mzn-sicstus -D n=4 queen.mzn

   *Please note*: The translator 'mzn2fzn' needs to be made aware of the
SICStus specific global constraint definitions, located in
'library('zinc/globals')'.  This is necessary in order for the
MiniZinc-to-FlatZinc translation to be SICStus specific.  If this is not
done, then the SICStus interpreter may run the resulting FlatZinc
program significantly slower.  In the commands given above, this is done
by the option '-G sicstus', which requires a symbolic link e.g.
'/opt/minizinc-2.1.6/share/minizinc/sicstus' pointing at
'library('zinc/globals')'.  If you are unable to add such a link, then
an alternative to '-G sicstus' is to pass the path to
'library('zinc/globals')' in the '--search-dir' option of 'mzn2fzn'.

   It is also possible to just load a FlatZinc program into SICStus by
'fzn_load_file/2' and 'fzn_load_stream/2'.  The loaded FlatZinc program
can then be processed further from within SICStus, e.g. by retrieving
some FlatZinc variables using 'fzn_identifier/3' and posting additional
'library(clpfd)' constraints or applying a Prolog labeling predicate on
those variables.

   Finally, it is also possible to load and run MiniZinc programs
directly from within SICStus by using the predicates described in *note
MiniZinc::.  These predicates all rely on the availability of an
external MiniZinc-to-FlatZinc translator such as 'mzn2fzn', as well as
an external solution printer such as 'solns2out' (*note MiniZinc::).


File: sicstus.info,  Node: FlatZinc Exported Predicates,  Up: FlatZinc

10.48.2.1 Exported Predicates
.............................

The predicates described here operate on a data structure FZNSTATE
representing a FlatZinc program and consisting of the following members:

   * A table that maps identifiers of the FlatZinc program to Prolog
     terms.
   * A list containing all domain variables of the FlatZinc program,
     except those with a 'var_is_introduced' annotation.
   * A list containing all domain variables of the FlatZinc program that
     may be written on the current output stream.
   * A goal representing the constraint part of the FlatZinc program.
   * A goal representing the solve part of the FlatZinc program.
   * A counter denoting the number of solutions found by the FlatZinc
     program.

   This data structure can be constructed from a FlatZinc program by the
predicates 'fzn_load_stream/2' and 'fzn_load_file/2' described next, or
directly from a MiniZinc program (*note MiniZinc::).

'fzn_load_stream(+FZNSTREAM, -FZNSTATE)'

     FZNSTREAM is a FlatZinc input stream.  FZNSTATE is a FlatZinc state
     that is initialized with respect to FZNSTREAM.

     _Exceptions:_ Exceptions regarding errors in FZNSTREAM (*note Zinc
     Errors::).

'fzn_load_file(+FZNFILE, -FZNSTATE)'

     FZNFILE is a FlatZinc file (extension defaults to '.fzn').
     FZNSTATE is a FlatZinc state that is initialized with respect to
     FZNFILE.  This predicate is just a wrapper around
     'fzn_load_stream/2' handling stream opening and closing.

     _Exceptions:_

        * Exceptions related to the opening of FZNFILE for reading.

        * Exceptions regarding errors in FZNFILE (*note Zinc Errors::).

   Consider the following FlatZinc program for solving the 4 Queens
problem located in 'library('zinc/examples/queen4.fzn')'.  _(Note that FlatZinc
programs are not intended to be written (or read) by humans, but rather
to be automatically generated.  One method to generate FlatZinc programs
is described in *note MiniZinc::.)_

                                                         _% queen4.fzn_
     int: n = 4;

     array[1 .. 4] of var 1 .. 4: q::output_array([ 1 .. 4 ]);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[2] ], 1);

     constraint int_ne(q[1], q[2]);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[2] ], -1);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[3] ], 2);

     constraint int_ne(q[1], q[3]);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[3] ], -2);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[4] ], 3);

     constraint int_ne(q[1], q[4]);

     constraint int_lin_ne([ 1, -1 ], [ q[1], q[4] ], -3);

     constraint int_lin_ne([ 1, -1 ], [ q[2], q[3] ], 1);

     constraint int_ne(q[2], q[3]);

     constraint int_lin_ne([ 1, -1 ], [ q[2], q[3] ], -1);

     constraint int_lin_ne([ 1, -1 ], [ q[2], q[4] ], 2);

     constraint int_ne(q[2], q[4]);

     constraint int_lin_ne([ 1, -1 ], [ q[2], q[4] ], -2);

     constraint int_lin_ne([ 1, -1 ], [ q[3], q[4] ], 1);

     constraint int_ne(q[3], q[4]);

     constraint int_lin_ne([ 1, -1 ], [ q[3], q[4] ], -1);

     solve satisfy;

   A FlatZinc state 'Queen4State' representing the program above can be
constructed by typing:

     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State).

   The predicates presented next are used to query an already
initialized FlatZinc state.

'fzn_post(+FZNSTATE)'

     Posts the constraints of the FlatZinc program represented by
     FZNSTATE.  May fail if the constraints are inconsistent.

'fzn_solve(+FZNSTATE)'

     Runs the solve and output parts of the FlatZinc program represented
     by FZNSTATE to find and display an (optimal) solution.  Fails if
     the constraints of the FlatZinc program are inconsistent.
     Generates the next solution upon backtracking.

'fzn_output(+FZNSTATE)'

     Outputs the values of the variables in FZNSTATE that have been
     annotated with 'output_var/0' or 'output_array/1'.

     _Exceptions:_ An _instatiation error_ if the output variables are
     not instantiated.

   Consider again the FlatZinc program 'queen4.fzn' described above and
the following goal at the Prolog top level:

     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State),
          fzn_post(Queen4State),
          fzn_solve(Queen4State).

   The first line initializes 'Queen4State' with respect to
'queen4.fzn'.  The second and third line posts the constraints of
'queen4.fzn' and runs the solve and output parts of 'queen4.fzn',
respectively.  The following is written on the current output stream:

     q = array1d(1..4, [2, 4, 1, 3]);
     ----------

   Upon backtracking the solve and output parts of 'Queen4State' are
rerun, which means that the following is written on the current output
stream:

     q = array1d(1..4, [3, 1, 4, 2]);
     ----------

'fzn_identifier(+FZNSTATE, +ID, -VALUE)'

     FZNSTATE is a FlatZinc state initialized with respect to some FlatZinc
     program and ID is an identifier of the FlatZinc program.  Unifies
     the FlatZinc value of ID with VALUE according to the following
     translation scheme:

        * A 'bool' is translated into a Prolog integer: 'false' is
          translated into '0' and 'true' is translated into '1'.
        * An 'int' is translated into a Prolog integer.
        * A 'float' is translated into a Prolog float.
        * An integer range or an integer set is translated into a
          'library(clpfd)' FD set term (*note FD Set Operations::).
        * A non-integer set is translated into a sorted Prolog list
          containing the (translated) elements of the set.
        * An array is translated into a Prolog list containing the
          (translated) elements of the array.  Ordering is preserved
          such that the _n_th element of the array is the _n_th element
          of the list.
        * A 'var int' is translated into a 'library(clpfd)' domain
          variable (*note CLPFD Interface::).
        * A 'var bool' is translated into a 'library(clpfd)' domain
          variable with the domain '0..1' (*note CLPFD Interface::).

     _Exceptions:_ An _existence error_ if ID is not an identifier of
     FZNSTATE.

'fzn_objective(+FZNSTATE, -OBJECTIVE)'

     FZNSTATE is a FlatZinc state initialized with respect to some FlatZinc
     program.  Unifies OBJECTIVE with a domain variable representing the
     FlatZinc objective.

     _Exceptions:_ An _existence error_ if there is no objective in
     FZNSTATE.

   A possible use of 'fzn_identifier/3' is to post additional
'library(clpfd)' constraints or to apply a Prolog labeling predicate on
the FlatZinc variables.  For example, given the 4 Queens problem in
'queen4.fzn' described above, the following goal labels the variables to
find all solutions:
     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State),
          fzn_post(Queen4State),
          fzn_identifier(Queen4State, q, Q),
          findall(_, (labeling([], Q), fzn_output(Queen4State)), _).
   Given this goal, the following is written on the current output
stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------
     q = array1d(1..4, [3, 1, 4, 2]);
     ----------
   To avoid symmetric solutions where the chess board is rotated 180
degrees, the following goal posts an additional symmetry breaking
constraint on the first two queens:
     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State),
          fzn_post(Queen4State),
          fzn_identifier(Queen4State, q, Q),
          Q = [Q1, Q2|_], Q1 #< Q2,
          findall(_, (labeling([], Q), fzn_output(Queen4State)), _).
   Given this goal, the following is written on the current output
stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------
   Note that, now, only the first one of the previous two solutions is
displayed.

   The following two predicates can be used to run a FlatZinc program in
one go.  They both take as optional argument a list OPTIONS, which can
be used to change the default behavior of the execution.  This list may
contain zero or more of the following:

'search(METHOD)   since release 4.3'
     where METHOD must be one of the atoms 'bab' and 'restart'.  Tells
     the solver which optimization algorithm to use: branch-and-bound
     (the default), or to restart the search each time a new solution is
     found.  The corresponding 'spfz' option is '-search METHOD'.

'solutions(NUMBEROFSOLUTIONS)'
     where NUMBEROFSOLUTIONS must be an integer greater than zero or the
     atom 'all'.  Describes the number of solutions to search for; the
     default is 1.  The corresponding 'spfz' options are '-n N' and
     '-a'.

'output(FILE)'
     where FILE must be the name of a writable file.  Causes any output
     written on the current output stream to be directed to FILE.  The
     corresponding 'spfz' option is '-o FILE'.

'ozn_file(FILE)   since release 4.2.3'
     where FILE must be the name of an existing file, containing the MiniZinc
     output commands that 'solns2out' should use.  If not given, then
     'solns2out' will not be used, and the solutions will be printed
     unformatted.

'statistics(BOOLEAN)'
     where BOOLEAN must be 'true' or 'false' (default).  The
     corresponding 'spfz' option is '-s'.  If 'true', the following
     statistics are written on the current output stream (see the
     built-in 'statistics/[0,2]' and 'fd_statistics/[0,2]' of
     'library(clpfd)' for more detailed information on their meaning):

     'runtime'
          Total running time (milliseconds), including parsing the FlatZinc
          program.

     'solvetime'
          Running time (milliseconds) for posting the constraints and
          performing the search.

     'solutions'
          The number of solutions found.

     'constraints'
          The number of constraints created.

     'backtracks'
          The number of times a contradiction was found by a domain
          being wiped out, or by a global constraint signalling failure.

     'prunings'
          The number of times a domain was pruned.

'timeout(TIME)'
     where TIME should be an integer greater than zero.  Stops the
     computation if it has not finished before TIME milliseconds has
     elapsed.  In any event, the best solution found so far is reported.
     The corresponding 'spfz' option is '-time TIME'.

'fzn_run_stream(+FZNSTREAM)'
'fzn_run_stream(+FZNSTREAM, +OPTIONS)'

     FZNSTREAM is a FlatZinc input stream and OPTIONS is a list of
     options as described above.  Performs the following steps:

       1. Loads the FlatZinc program ('fzn_load_stream/2'), initializing
          a FlatZinc state.
       2. Posts the constraints of the FlatZinc program ('fzn_post/1').
       3. Runs the solve part of the FlatZinc program ('fzn_solve/1').
       4. Outputs the values of the variables that have been annotated
          with 'output_var/0' or 'output_array/1'.

     The two final steps are repeated until the number of solutions as
     specified in OPTIONS have been found or until no more solutions can
     be found.  At this point, if the whole search space have been
     explored, then ten consecutive equal signs are output on a separate
     line.

     _Exceptions:_

        * A _type error_ if the number of solutions to search for is not
          greater than zero nor the atom 'all'.

        * Exceptions regarding errors in FZNSTREAM (*note Zinc
          Errors::).

'fzn_run_file(+FZNFILE)'
'fzn_run_file(+FZNFILE, +OPTIONS)'

     FZNFILE is a FlatZinc program file (extension defaults to '.fzn')
     and OPTIONS is a list of options as described above.  This
     predicate is just a wrapper around 'fzn_run_stream/[1,2]' handling
     stream opening and closing.

     _Exceptions:_

        * Exceptions related to the opening of FZNFILE for reading.

        * A _type error_ if the number of solutions to search for is not
          greater than zero nor the atom 'all'.

        * Exceptions regarding errors in FZNFILE (*note Zinc Errors::).

   The next predicate can be used to write the constraints of a FlatZinc
program to a file, in the format of 'library(clpfd)'.

'fzn_dump(+FZNSTATE, +FILE)'
'fzn_dump(+FZNSTATE, +OPTIONS, +FILE)'

     FZNSTATE is a FlatZinc state initialized with respect to some FlatZinc
     program and FILE is a writable file (extension defaults to '.pl').
     Writes the constraints of FZNSTATE to FILE in the format of
     'library(clpfd)'.

     OPTIONS is a list containing zero or more of the following
     (currently, this is the only available option):

     'variables(LISTOFVARDEF)'
          where LISTOFVARDEF is a list of elements of the form ID=VAR
          where ID is a FlatZinc identifier and VAR is a Prolog
          variable.  Means that VAR is unified with the value of ID
          after the FlatZinc program is loaded and that ID=VAR is
          included in a list of arguments to 'query/1' that is written
          to FILE.  Default is LISTOFVARDEF='[vars=Vars]', with the
          meaning that VARS is a list containing all variables of the FlatZinc
          state, in the order they were introduced.

     _Exceptions:_ Exceptions related to the opening of FILE for
     writing.

   Consider again the FlatZinc program 'queen4.fzn' described above and
the following goal at the Prolog top level:

     | ?- fzn_load_file(library('zinc/examples/queen4'), Queen4State),
          fzn_dump(Queen4State, [variables([q=Q])], queen4).

   The file 'queen4.pl' then contains the following:

                                                            _queen4.pl_
     :- use_module(library(clpfd)).

     query([q=[A,B,C,D]]) :-
             true,
             domain([A,B,C,D], 1, 4),
             scalar_product([1,-1], [A,B], #\=, -1),
             scalar_product([1,-1], [A,B], #\=, 1),
             scalar_product([1,-1], [A,C], #\=, -2),
             scalar_product([1,-1], [A,C], #\=, 2),
             scalar_product([1,-1], [A,D], #\=, -3),
             scalar_product([1,-1], [A,D], #\=, 3),
             scalar_product([1,-1], [B,C], #\=, -1),
             scalar_product([1,-1], [B,C], #\=, 1),
             scalar_product([1,-1], [B,D], #\=, -2),
             scalar_product([1,-1], [B,D], #\=, 2),
             scalar_product([1,-1], [C,D], #\=, -1),
             scalar_product([1,-1], [C,D], #\=, 1),
             A#\=B,
             A#\=C,
             A#\=D,
             B#\=C,
             B#\=D,
             C#\=D.


File: sicstus.info,  Node: MiniZinc,  Next: Zinc Errors,  Prev: FlatZinc,  Up: lib-zinc

10.48.3 MiniZinc
----------------

* Menu:

* MiniZinc Prerequisites:: Prerequisites
* MiniZinc Exported Predicates:: Exported Predicates

The predicates described here make it possible to load and run MiniZinc
programs directly from within SICStus and require an external
MiniZinc-to-FlatZinc translator.  In this way, the predicates described
here are essentially wrappers to the predicates described in *note
FlatZinc::, handling the MiniZinc-to-FlatZinc translation and providing
a more high-level interface.


File: sicstus.info,  Node: MiniZinc Prerequisites,  Next: MiniZinc Exported Predicates,  Up: MiniZinc

10.48.3.1 Prerequisites
.......................

An external MiniZinc-to-FlatZinc translator must be made available to
SICStus and must accept:
   * a MiniZinc program file '<model>.mzn' as only argument.
   * the option '--no-optimise' with the meaning that the translation
     should be unoptimized.
   * the option '--output-fzn-to-file' FILE with the meaning that the
     translated FlatZinc program is written onto FILE.
   * the option '--output-ozn-to-file' FILE with the meaning that the
     output commands of the FlatZinc program are written onto FILE.
   * (multiple instances of) the option '--data' FILE with the meaning
     that FILE is an included MiniZinc data file.
   * (multiple instances of) the option '--search-dir' DIR with the
     meaning that DIR is searched for MiniZinc data files and solver
     specific global constraint definitions.

   There are two ways to make such a translator available to SICStus:
  1. Set the environment variable 'MZN2FZN' to the location of the
     translator executable.
  2. Put a translator executable named 'mzn2fzn' in a directory included
     in the 'PATH' environment variable.

   An external solution printer, such as 'solns2out', should be
available to SICStus.  This can be done in two ways:
  1. Set the environment variable 'SOLNS2OUT' to the location of the
     translator executable.
  2. Put a translator executable named 'solns2out' in a directory
     included in the 'PATH' environment variable.

   The MiniZinc distribution includes such 'mzn2fzn' and 'solns2out'
programs.  See <http://www.minizinc.org> for more information and
download links.


File: sicstus.info,  Node: MiniZinc Exported Predicates,  Prev: MiniZinc Prerequisites,  Up: MiniZinc

10.48.3.2 Exported Predicates
.............................

The following predicates all take as (optional) argument a list OPTIONS,
which can be used to change the default behavior of the execution.  This
list may contain zero or more of the following:

'data_file(MZNDATFILE)'
     where MZNDATFILE must be a MiniZinc data file.  Means that
     MZNDATFILE is passed to 'mzn2fzn' through the '--data' option.

'parameters(LISTOFPARDEF)'
     where LISTOFPARDEF is a list of elements of the form ID=VALUE where
     ID is a MiniZinc identifier and VALUE is a MiniZinc value.  Means
     that all elements are written to a temporary file, which is passed
     to 'mzn2fzn' through the '--data' option.

'post(BOOLEAN)'
     where BOOLEAN must be 'true' or 'false'.  If 'true' (the default),
     then the constraints of the MiniZinc program are posted directly
     and a separate call to 'fzn_post/1' (*note FlatZinc Exported
     Predicates::) is not necessary.  (Only usable with
     'mzn_load_file/3' and 'mzn_load_model/3'.)

'search(METHOD)   since release 4.3'
     where METHOD must be one of the atoms 'bab' and 'restart'.  Tells
     the solver which optimization algorithm to use: branch-and-bound
     (the default), or to restart the search each time a new solution is
     found.  (Only usable with 'mzn_run_file/2' and 'mzn_run_model/2'.)

'solutions(NUMBEROFSOLUTIONS)'
     where NUMBEROFSOLUTIONS must be an integer greater than zero or the
     atom 'all'.  Describes the number of solutions to search for,
     default is 1.  (Only usable with 'mzn_run_file/2' and
     'mzn_run_model/2'.)

'output(FILE)'
     where FILE must be the name of a writable file.  Causes any output
     written on the current output stream to be directed to FILE.  (Only
     usable with 'mzn_run_file/2' and 'mzn_run_model/2'.)

'fzn_file(FILE)   since release 4.2.3'
     where FILE must be the name of a writable file.  The translated FlatZinc
     program will be written to the given file.  Otherwise, a temporary
     file will be used and erased afterwards.

'ozn_file(FILE)   since release 4.2.3'
     where FILE must be the name of a writable file.  The MiniZinc
     output commands will be written to the given file.  Otherwise, a
     temporary file will be used and erased afterwards.

'optimise(BOOLEAN)   since release 4.2.3'
'optimize(BOOLEAN)   since release 4.2.3'
     where BOOLEAN must be 'true' (the default) or 'false'.  If 'false',
     then '--no-optimise' is passed to 'mzn2fzn'.

'statistics(BOOLEAN)'
     where BOOLEAN must be 'true' or 'false' (default).  If 'true', then
     the following statistics are written on the current output stream
     (see the built-in 'statistics/[0,2]' and 'fd_statistics/[0,2]' of
     'library(clpfd)' for more detailed information on their meaning):

     'runtime'
          Total running time (milliseconds), including parsing the FlatZinc
          program.

     'solvetime'
          Running time (milliseconds) for posting the constraints and
          performing the search.

     'solutions'
          The number of solutions found.

     'constraints'
          The number of constraints created.

     'backtracks'
          The number of times a contradiction was found by a domain
          being wiped out, or by a global constraint signalling failure.

     'prunings'
          The number of times a domain was pruned.
     (Only usable with 'mzn_run_file/2' and 'mzn_run_model/2'.)

'timeout(TIME)'
     where TIME should be an integer greater than zero.  Stops the
     computation if it has not finished before TIME milliseconds has
     elapsed.  In any event, the best solution found so far is reported.
     Measuring starts after the call to 'mzn2fzn' has finished.  (Only
     usable with 'mzn_run_file/2' and 'mzn_run_model/2'.)

'variables(LISTOFVARDEF)'
     where LISTOFVARDEF is a list of elements of the form ID=VAR where
     ID is a MiniZinc identifier and VAR is a Prolog variable.  Means
     that VAR is unified with the value of ID after the MiniZinc program
     is loaded.  (Only usable with 'mzn_load_file/3' and
     'mzn_load_model/3').

   The first two predicates can be used to run a MiniZinc program in one
go.

'mzn_run_file(+MZNFILE)'
'mzn_run_file(+MZNFILE, +OPTIONS)'

     MZNFILE is a MiniZinc program file and OPTIONS is a list of options
     as described above.  Runs the MiniZinc program on MZNFILE, and
     writes the result onto the file given in the 'option/1' option if
     given, or onto the current output stream otherwise.  This is done
     by first calling 'mzn2fzn', and then interpreting its output with
     'fzn_run_stream/[1,2]' (*note FlatZinc Exported Predicates::).
     Fails if the constraints of the MiniZinc program are inconsistent.

     _Exceptions:_

        * Exceptions related to the opening of MZNFILE for reading.

        * A _system error_ if 'mzn2fzn' is unsuccessful.  This error
          will include any information produced by 'mzn2fzn' on its
          standard error stream.

        * A _type error_ if the number of solutions to search for is not
          greater than zero nor the atom 'all'.

        * Exceptions regarding errors in MZNFILE (*note Zinc Errors::)
          although these are most probably already handled by 'mzn2fzn'.

'mzn_run_model(+MZNMODEL)'
'mzn_run_model(+MZNMODEL, +OPTIONS)'

     MZNMODEL is a MiniZinc program specified by a list of strings as
     explained below and OPTIONS is a list of options as described
     above.  Runs the MiniZinc program MZNMODEL, and writes the result
     onto the file given in the 'option/1' option if given, or onto the
     current output stream otherwise.  This is done by first calling
     'mzn2fzn' and interpreting its output with 'fzn_run_stream/[1,2]'
     (*note FlatZinc Exported Predicates::).  The MiniZinc program
     specification MZNMODEL must be a list of strings (list of character
     codes) where each element must specify one line of the MiniZinc
     program.  For example, a MiniZinc program for the N Queens problem
     can be specified as follows:
          NQueens = ["int: n;",
                     "array [1..n] of var 1..n: q;",
                     "constraint forall (i in 1..n, j in i+1..n)",
                         "(q[i] != q[j] /\\",
                          "q[i] + i != q[j] + j /\\",
                          "q[i] - i != q[j] - j);",
                     "solve satisfy;",
                     "output [\"A solution to the \", show(n),",
                     "\" Queens problem: \", show(q), \"\\n\"];"]
     *Note that* backslashes and double quotes must be escaped with an
     additional backslash.

     _Exceptions:_

        * A _system error_ if 'mzn2fzn' is unsuccessful.  This error
          will include any information produced by 'mzn2fzn' on its
          standard error stream.

        * A _type error_ if the number of solutions to search for is not
          greater than zero nor the atom 'all'.

        * Exceptions regarding errors in MZNMODEL (*note Zinc Errors::)
          although these are most probably already handled by 'mzn2fzn'.

   Consider the following MiniZinc program for solving the N Queens
problem located in 'library('zinc/examples/queen.mzn')':
                                                            _queen.mzn_
     int: n;

     array [1..n] of var 1..n: q;

     constraint
         forall (i in 1..n, j in i+1..n) (
             q[i] != q[j] /\
             q[i] + i != q[j] + j /\
             q[i] - i != q[j] - j
         );

     solve satisfy;

     output ["A solution to the ", show(n), " Queens problem: ", show(q), "\n"];

   Consider now the following goal at the Prolog top level:

     | ?- mzn_run_file(library('zinc/examples/queen'),
                       [data_file(library('zinc/examples/queen4.dat'))]).

   Since 'library('zinc/examples/queen4.dat')' contains the single line
     n = 4;
   the following is written on the current output stream:
     A solution to the 4 Queens problem: [2, 4, 1, 3]
     ----------

   The initialization 'n = 4' can also be passed using the 'parameter/1'
option.  So the following goal is equivalent to the one above:
     | ?- mzn_run_file(library('zinc/examples/queen'), [parameters([n=4])]).

   Finally, the following goal finds all solutions to the 4 Queens
problem:
     | ?- mzn_run_file(library('zinc/examples/queen'),
                       [parameters([n=4]), solutions(all)]).
   Given this goal, the following is written on the current output
stream:
     A solution to the 4 Queens problem: [2, 4, 1, 3]
     ----------
     A solution to the 4 Queens problem: [3, 1, 4, 2]
     ----------
     ==========

   The next two predicates can be used to construct a FlatZinc state
(*note FlatZinc Exported Predicates::).

'mzn_load_file(+MZNFILE, -FZNSTATE)'
'mzn_load_file(+MZNFILE, +OPTIONS, -FZNSTATE)'

     MZNFILE is a MiniZinc program file and OPTIONS is a list of options
     as described above.  Initializes a FlatZinc state FZNSTATE with
     respect to MZNFILE.  May fail if 'post(true)' and the constraints
     are inconsistent.

     _Exceptions:_

        * Exceptions related to the opening of MZNFILE for reading.

        * A _system error_ if 'mzn2fzn' is unsuccessful.  This error
          will include any information produced by 'mzn2fzn' on its
          standard error stream.

        * An _existence error_ if an ID of the 'variables/1' option is
          not an identifier of FZNSTATE.

        * Exceptions regarding errors in MZNFILE (*note Zinc Errors::)
          although these are most probably already handled by 'mzn2fzn'.

'mzn_load_model(+MZNMODEL, -FZNSTATE)'
'mzn_load_model(+MZNMODEL, +OPTIONS, -FZNSTATE)'

     MZNMODEL is a MiniZinc program specified by a list of strings as
     explained for 'mzn_run_model/[1,2]' above and OPTIONS is a list of
     options as described above.  Initializes a FlatZinc state FZNSTATE
     with respect to MZNMODEL.  May fail if 'post(true)' and the
     constraints are inconsistent.

     _Exceptions:_

        * A _system error_ if 'mzn2fzn' is unsuccessful.  This error
          will include any information produced by 'mzn2fzn' on its
          standard error stream.

        * An _existence error_ if an ID of the 'variables/1' option is
          not an identifier of FZNSTATE.

        * Exceptions regarding errors in MZNMODEL (*note Zinc Errors::)
          although these are most probably already handled by 'mzn2fzn'.

   The following Prolog goal constructs a FlatZinc state representing
the 4 Queens problem:
     | ?- mzn_load_file(library('zinc/examples/queen'),
                        [parameters([n=4])], Queen4State).

   See *note FlatZinc Exported Predicates:: for more information on FlatZinc
states and how they can be queried.  A very useful option to
'mzn_load_file/3' and 'mzn_load_model/3' is the 'variables/1' option,
which can be used to unify values of MiniZinc identifiers with Prolog
variables (this option can be used in place of several calls to
'fzn_identifier/3').  For example, the following goal posts an
additional symmetry breaking constraint and labels the variables using a
Prolog goal that finds all remaining solutions to the 4 Queens problem:
     | ?- mzn_load_file(library('zinc/examples/queen'),
                        [parameters([n=4]), variables([q=Q])],
                        Queen4State),
          Q = [Q1, Q2|_], Q1 #< Q2,
          findall(_, (labeling([], Q), fzn_output(Queen4State)), _).
   Given this goal, the following is written on the current output
stream:
     q = array1d(1..4, [2, 4, 1, 3]);
     ----------

   The final predicate can be used to translate a MiniZinc file to a FlatZinc
by a direct call to 'mzn2fzn'.

'mzn_to_fzn(+MZNFILE, +FZNFILE)'
'mzn_to_fzn(+MZNFILE, +OPTIONS, +FZNFILE)'

     MZNFILE is a MiniZinc program file and OPTIONS is a list of options
     as described above.  Calls 'mzn2fzn', whose result is written to
     FZNFILE.

     _Exceptions:_

        * Exceptions related to the opening of MZNFILE for reading as
          well as the opening of FZNFILE for writing.

        * A _system error_ if 'mzn2fzn' is unsuccessful.  This error
          will include any information produced by 'mzn2fzn' on its
          standard error stream.

        * Exceptions regarding errors in MZNFILE (*note Zinc Errors::)
          although these are most probably already handled by 'mzn2fzn'.

* Menu:

* Zinc Errors:: Zinc Errors


File: sicstus.info,  Node: Zinc Errors,  Prev: MiniZinc,  Up: lib-zinc

10.48.4 Zinc Errors
-------------------

The following is a list of exceptions that may be generated by the
predicates described in *note FlatZinc Exported Predicates:: and in
*note MiniZinc Exported Predicates:: when there is an error in the FlatZinc
or MiniZinc input.

   * A _syntax error_ occurs when the parser cannot continue.  For
     example, the FlatZinc code:
          array[1..2] of int a = [1, 2];
     generates the following error (since there must be a colon between
     'int' and 'a'):
          ! Item ending on line 1:
          ! Syntax error
          ! expected `:' but found `ident(a)'
     The line number indicates the ending line of the item containing
     the error.  *Note that* this means that the error may be on a
     preceding line, if the item occupies several lines.

   * A _consistency error_ occurs when the same identifier is used
     multiple times.  For example, the FlatZinc code:
          bool : b = false;
          bool : b = true;
     generates the following error:
          ! Item ending on line 2:
          ! Consistency error: `b' is already defined
          ! previous definition of b was `bool : b = false'
          ! cannot redefine b to `bool : b = true'

   * An _existence error_ occurs when an identifier or a constraint is
     used without being previously defined.  For example, the FlatZinc
     code:
          bool : b = a;
     may generate the following error:
          ! Item ending on line 2:
          ! Existence error
          ! `a' is not defined
     Another example, the FlatZinc code:
          var int : a;
          var int : b;
          constraint distance(a, b, 1);
     may generate the following error:
          ! Item ending on line 4:
          ! Existence error
          ! `distance/3' is not defined

   * A _type error_ occurs when a value is of the wrong type.  For
     example, the FlatZinc code:
          var float : f;
     generates the following error (since only finite domain integer
     variables are supported):
          ! Item ending on line 2:
          ! Type error
          ! `f' must be a member of `int'

     Another example, the FlatZinc code:
          array[1..2] of float : a = [2.1, 3];
     generates the following error (since an array of floats cannot
     contain integers):
          ! Item ending on line 2:
          ! Type error
          ! `3' must be a member of `float'

     A type error also occurs when an array index is out of bounds.  For
     example, the FlatZinc code:
          array[1..2] of int : a = [1, 2];
          int : i = a[3];
     generates the following error:
          ! Item ending on line 3:
          ! Type error in array index
          ! index evaluates to 3 but must be in 1..2


File: sicstus.info,  Node: Prolog Reference Pages,  Next: C Reference Pages,  Prev: The Prolog Library,  Up: Top

11 Prolog Reference Pages
*************************

* Menu:

* mpg-ref::                             Reading the Reference Pages
* mpg-top::                             Topical List of Prolog Built-Ins
* mpg-bpr::                             Built-In Predicates


File: sicstus.info,  Node: mpg-ref,  Next: mpg-top,  Up: Prolog Reference Pages

11.1 Reading the Reference Pages
================================

* Menu:

* mpg-ref-ove::                         Overview
* mpg-ref-mod::                         Mode Annotations
* mpg-ref-cat::                         Predicate Annotations
* mpg-ref-aty::                         Argument Types
* mpg-ref-exc::                         Exceptions
* mpg-ref-oth::                         Other Fields


File: sicstus.info,  Node: mpg-ref-ove,  Next: mpg-ref-mod,  Up: mpg-ref

11.1.1 Overview
---------------

The reference pages for SICStus Prolog built-in predicates conform to
certain conventions concerning

   * mode annotations
   * predicate annotations
   * argument types

   These are particularly important in utilizing the Synopsis and
Arguments fields of each reference page.  The Synopsis field consists of
the goal template(s) with mode annotations and a brief description of
the purpose of the predicate.  For example, consider this excerpt from
the reference page for 'assert/[1,2]':

Synopsis
--------

These predicates add a dynamic clause, CLAUSE, to the Prolog database.
They optionally return a database reference in REF:

   'assert(+CLAUSE)'

   'assert(+CLAUSE, -REF)'

   It is undefined whether CLAUSE will precede or follow the clauses
already in the database.

   The Arguments field lists, for each meta-variable name in the
template, its argument type, (e.g. "callable"), a brief description
(sometimes omitted), and an indication (':') if it does module name
expansion.  For example,

Arguments
---------

:CLAUSE
     "callable" A valid dynamic Prolog clause.
REF
     "db_reference" a database reference, which uniquely identifies the
     newly asserted CLAUSE.


File: sicstus.info,  Node: mpg-ref-mod,  Next: mpg-ref-cat,  Prev: mpg-ref-ove,  Up: mpg-ref

11.1.2 Mode Annotations
-----------------------

The mode annotations are useful to tell whether an argument is input or
output or both.  They also describe formally the instantiation pattern
to the call that makes the call to the built-ins determinate.

   The mode annotations in the above example are '+' and '-'.  Following
is a complete description of the mode annotations you will find in the
reference pages:

'+'
     Input argument.  This argument will be inspected by the predicate,
     and affects the behavior of the predicate.  An exception is raised
     if the argument is not of the expected type.  Note that an input
     argument can be an unbound variable in some cases.

'-'
     Output argument.  This argument is unified with the output value of
     the predicate.  An output argument is only tested to be of the same
     type as the possible output value if this is prescribed by the ISO
     standard, or if such testing is deemed helpful to the user.

'?'
     An argument that could be either input or output.  This mode
     annotation is normally only used for predicates that behave as pure
     relations and do not type test their arguments.

   If the synopsis of a predicate has more than one mode declaration,
then the first (the topmost) that satisfies the types (of a goal
instance) is the one to be applied (to that goal instance).

   All built-in predicates of arity zero are determinate (with the
exception of 'repeat/0').

   For _input_ arguments, an exception _will_ be raised if the argument
is not of the specified type.

   For _output_ arguments, an exception _might_ be raised if the
argument is "nonvar", and not of the specified type.  The generated
_value_ of the argument _will_ be of the specified type.


File: sicstus.info,  Node: mpg-ref-cat,  Next: mpg-ref-aty,  Prev: mpg-ref-mod,  Up: mpg-ref

11.1.3 Predicate Annotation
---------------------------

This section describes the annotations of predicates and how they are
indicated in the reference pages for predicates of each given
annotation.  The annotations appear to the right of the title of the
reference page.

"hookable"
     The behavior of the predicate can be customized/redefined by
     defining one or more hooks.  The mode and type annotations of a
     hookable predicate might not be absolute, since hooks added by the
     user can change the behavior.

"hook"
     The predicate is user defined, and is called by a "hookable"
     builtin.  Most hooks must be defined in module 'user'.  For a hook,
     the mode and type annotations should be seen as guide-lines to the
     user who wants to add his own hook; they describe how the predicate
     is used by the system.

"extendible"
     A multifile predicate, to which new clauses can be added by the
     user.  For such a predicate, the mode and type annotations should
     be seen as guide-lines to the user who wants to extend the
     predicate; they describe how the predicate is used by the system.

"declaration"
     You cannot call these directly but they can appear in files as ':-
     DECLARATION' and give information to the compiler.  The goal
     template is preceded by ':-' in the Synopsis.

"development"
     A predicate that is defined in the development system only, i.e.
     not in runtime systems.

"ISO"
     A predicate that is part of the ISO Prolog Standard.

"deprecated"
     A predicate that is not recommended in new code and that could be
     withdrawn in a future release.

   "Meta-predicates" and "operators" are recognizable by the implicit
conventions described below.

   * "Meta-predicates" are predicates that need to assume some module.
     The reference pages of these predicates indicate which arguments
     are in a module expansion position by prefixing such arguments by
     ':' in the Arguments field.  That is, the argument can be preceded
     by a module prefix (an "atom" followed by a colon).  For example:
          assert(mod:a(1), Ref)
     If no module prefix is supplied, then it will implicitly be set to
     the calling module.  If the module prefix is a variable, then an
     instantiation error will be raised.  If it is not an atom, then a
     type error will be raised.  So in any meta-predicate reference page
     the following exceptions are implicit:

     Exceptions
---------------

     'instantiation_error'
          A module prefix is written as a variable.

     'type_error'
          A module prefix is not an atom.

   * Whenever the name of a built-in predicate is defined as "operator",
     the name is presented in the Synopsis as an operator, for example
          :- initialization +GOAL                   (A)
          +TERM1 @> +TERM2               (B)

     It is thus always possible to see if a name is an operator or not.
     The predicate can, of course, be written using the canonical
     representation, even when the name is an operator.  Thus (A) and
     (B) can be written as (C) and (D), respectively:
          :- initialization(+GOAL)                   (C)
          @>(+TERM1,  +TERM2)                 (D)


File: sicstus.info,  Node: mpg-ref-aty,  Next: mpg-ref-exc,  Prev: mpg-ref-cat,  Up: mpg-ref

11.1.4 Argument Types
---------------------

* Menu:

* mpg-ref-aty-sim::                     Simple Types
* mpg-ref-aty-ety::                     Extended Types

The argument section describes the type/domain of each argument of a
_solution_ to the given predicate.  That is, for a predicate to succeed,
it must be possible to instantiate the given argument to a term of the
described type/domain.

   If it is a '+' argument, then the predicate always tests if the
argument is of the right type/domain.  Usually, input arguments must
also be instantiated to some extent.  Such details are documented for
each input argument.

   Many built-in and library predicates take an +OPTIONS argument, which
must be given as a proper list of terms specifying what the predicate
should do, typically as the last argument.  As a general rule for such
option lists, if the same option occurs more than once, then the last
occurrence overrides previous ones.


File: sicstus.info,  Node: mpg-ref-aty-sim,  Next: mpg-ref-aty-ety,  Up: mpg-ref-aty

11.1.4.1 Simple Types
.....................

The simple argument types are those for which type tests are provided.
They are summarized in *note mpg-top-typ::.

   If an output argument is given the type "var", then it means that
that argument is not used by the predicate in the given instantiation
pattern.


File: sicstus.info,  Node: mpg-ref-aty-ety,  Prev: mpg-ref-aty-sim,  Up: mpg-ref-aty

11.1.4.2 Extended Types
.......................

Following is a list of argument types that are defined in terms of the
simple argument types.  This is a formal description of the
types/domains used in the Arguments sections of the reference pages for
the built-ins.  The rules are given in BNF (Backus-Naur form).

BBKEY              ::= 'atom' | 'integer' {where the integer is small}
STREAM_OBJECT      ::= TERM {as defined in *note ref-iou-sfh-sob::}
TERM               ::= {any Prolog term}
LIST OF TYPE       ::= '[]' | '[TYPE|LIST OF TYPE]'
VAR OR TYPE        ::= VAR | TYPE
ONE OF             ::= ELEMENT | ONE OF REST
[ELEMENT|REST]
ARITY              ::= {an INTEGER X in the range 0..255}
BYTE               ::= {an INTEGER X in the range 0..255}
CHAR               ::= {an ATOM consisting of a single character}
CHARS              ::= LIST OF CHAR
CODE               ::= {an INTEGER X >= 0}
CODES              ::= LIST OF CODE
ORDER              ::= {an ATOM, one of '[<,=,>]'}
PAIR               ::= 'TERM-TERM'
SIMPLE_PRED_SPEC   ::= 'ATOM/ARITY'
PRED_SPEC          ::= SIMPLE_PRED_SPEC | 'ATOM:PRED_SPEC'
PRED_SPEC_FOREST   ::= '[]' | PRED_SPEC
                   | '[PRED_SPEC_FOREST|PRED_SPEC_FOREST]'
                   | 'PRED_SPEC_FOREST,PRED_SPEC_FOREST'
PRED_SPEC_TREE     ::= PRED_SPEC | LIST OF PRED_SPEC
FOREIGN_SPEC       ::= CALLABLE {all arguments being FOREIGN_ARG}
FOREIGN_ARG        ::= '+INTERF_ARG_TYPE' | '-INTERF_ARG_TYPE' |
                   '[-INTERF_ARG_TYPE]'
INTERF_ARG_TYPE    ::= 'integer' | 'float' | 'atom'
                   | 'term' | 'codes' | 'string' | 'address' |
                   'address(ATOM)'
                   {see the description in *note Conversions between
                   Prolog Arguments and C Types::}
FILE_SPEC          ::= ATOM | 'ATOM(FILE_SPEC)'
EXPR               ::= {everything that is accepted as second argument
                   to 'is/2';
                   see the description of arithmetic expressions in
                   *note ref-ari-aex::.}


File: sicstus.info,  Node: mpg-ref-exc,  Next: mpg-ref-oth,  Prev: mpg-ref-aty,  Up: mpg-ref

11.1.5 Exceptions
-----------------

The Exceptions field of the reference page consists of a list of
exception type names, each followed by a brief description of the
situation that causes that type of exception to be raised.  The
following example comes from the reference page for 'assert/[1,2]':

Exceptions
----------

'instantiation_error'
     If HEAD (in CLAUSE) or M is uninstantiated.

'type_error'
     If HEAD is not of type callable, or if M is not an atom, or if BODY
     is not a valid clause body.

   For _input_ arguments, an exception _will_ be raised if the argument
is not of the specified type.

   For _output_ arguments, an exception _might_ be raised if the
argument is "nonvar", and not of the specified type.  The generated
_value_ of the argument _will_ be of the specified type.


File: sicstus.info,  Node: mpg-ref-oth,  Prev: mpg-ref-exc,  Up: mpg-ref

11.1.6 Other Fields
-------------------

The Backtracking field, if included, describes how the predicate behaves
on backtracking.  If this field is omitted, then the predicate is
determinate (succeeds at most once).

   The See Also field contains cross references to related predicates
and/or manual sections.

   Reference pages may also include Comments, Examples, and Tips fields,
when appropriate.


File: sicstus.info,  Node: mpg-top,  Next: mpg-bpr,  Prev: mpg-ref,  Up: Prolog Reference Pages

11.2 Topical List of Prolog Built-Ins
=====================================

* Menu:

* mpg-top-all::                         All Solutions
* mpg-top-ari::                         Arithmetic
* mpg-top-cio::                         Character I/O
* mpg-top-con::                         Control
* mpg-top-dat::                         Database
* mpg-top-deb::                         Debugging
* mpg-top-est::                         Errors and Exceptions
* mpg-top-fnm::                         Filename Manipulation
* mpg-top-fsh::                         File and Stream Handling
* mpg-top-fin::                         Foreign Interface
* mpg-top-gru::                         Grammar Rules
* mpg-top-hok::                         Hook Predicates
* mpg-top-lis::                         List Processing
* mpg-top-lod::                         Loading Programs
* mpg-top-mem::                         Memory
* mpg-top-msg::                         Messages and Queries
* mpg-top-mod::                         Modules
* mpg-top-sta::                         Program State
* mpg-top-eqs::                         Saving Programs
* mpg-top-tcm::                         Term Comparison
* mpg-top-tha::                         Term Handling
* mpg-top-tio::                         Term I/O
* mpg-top-typ::                         Type Tests

Following is a complete list of SICStus Prolog built-in predicates,
arranged by topic.  A predicate may be included in more than one list.


File: sicstus.info,  Node: mpg-top-all,  Next: mpg-top-ari,  Up: mpg-top

11.2.1 All Solutions
--------------------

'?X ^ :P'
     there exists an X such that P is provable (used in 'setof/3' and
     'bagof/3')

'bagof(?X,:P,-B)   ISO'
     B is the bag of instances of X such that P is provable

'findall(?T,:G,-L)   ISO'
'findall(?T,:G,?L,?R)'
     L is the list of all solutions T for the goal G, concatenated with
     R or with the empty list

'setof(?X,:P,-S)   ISO'
     S is the set of instances of X such that P is provable


File: sicstus.info,  Node: mpg-top-ari,  Next: mpg-top-cio,  Prev: mpg-top-all,  Up: mpg-top

11.2.2 Arithmetic
-----------------

'-Y is +X   ISO'
     Y is the value of arithmetic expression X

'+X =:= +Y   ISO'
     the results of evaluating terms X and Y as arithmetic expressions
     are equal.

'+X =\= +Y   ISO'
     the results of evaluating terms X and Y as arithmetic expressions
     are not equal.

'+X < +Y   ISO'
     the result of evaluating X as an arithmetic expression is less than
     the result of evaluating Y as an arithmetic expression.

'+X >= +Y   ISO'
     the result of evaluating X as an arithmetic expression is not less
     than the result of evaluating Y as an arithmetic expression.

'+X > +Y   ISO'
     the result of evaluating X as an arithmetic expression X is greater
     than the result of evaluating Y as an arithmetic expression.

'+X =< +Y   ISO'
     the result of evaluating X as an arithmetic expression is not
     greater than the result of evaluating Y as an arithmetic
     expression.


File: sicstus.info,  Node: mpg-top-cio,  Next: mpg-top-con,  Prev: mpg-top-ari,  Up: mpg-top

11.2.3 Character I/O
--------------------

'at_end_of_line'
'at_end_of_line(+S)'
     testing whether at end of line on input stream S

'at_end_of_stream   ISO'
'at_end_of_stream(+S)   ISO'
     testing whether end of file is reached for the input stream S

'flush_output   ISO'
'flush_output(+S)   ISO'
     flush the output buffer for stream S

'get_byte(-C)   ISO'
'get_byte(+S,-C)   ISO'
     C is the next byte on binary input stream S

'get_char(-C)   ISO'
'get_char(+S,-C)   ISO'
     C is the next character atom on text input stream S

'get_code(-C)   ISO'
'get_code(+S,-C)   ISO'
     C is the next character code on text input stream S

'nl           ISO'
'nl(+S)   ISO'
     send a newline to stream S

'peek_byte(+C)   ISO'
'peek_byte(+S,+C)   ISO'
     looks ahead for next input byte on the binary input stream S

'peek_char(+C)   ISO'
'peek_char(+S,+C)   ISO'
     looks ahead for next input character atom on the text input stream
     S

'peek_code(+C)   ISO'
'peek_code(+S,+C)   ISO'
     looks ahead for next input character code on the text input stream
     S

'put_byte(+C)   ISO'
'put_byte(+S,+C)   ISO'
     write byte C to binary stream S

'put_char(+C)   ISO'
'put_char(+S,+C)   ISO'
     write character atom C to text stream S

'put_code(+C)   ISO'
'put_code(+S,+C)   ISO'
     write character code C to text stream S

'skip_byte(+C)'
'skip_byte(+S,+C)'
     skip input on binary stream S until after byte C

'skip_char(+C)'
'skip_char(+S,+C)'
     skip input on text stream S until after char C

'skip_code(+C)'
'skip_code(+S,+C)'
     skip input on text stream S until after code C

'skip_line'
'skip_line(+S)'
     skip the rest input characters of the current line (record) on the
     input stream S


File: sicstus.info,  Node: mpg-top-con,  Next: mpg-top-dat,  Prev: mpg-top-cio,  Up: mpg-top

11.2.4 Control
--------------

':P,:Q           ISO'
     prove P and Q

':P;:Q           ISO'
     prove P or Q

'+M::P           ISO'
     call P in module M

':P->:Q;:R           ISO'
     if P succeeds, prove Q; if not, prove R

':P->:Q           ISO'
     if P succeeds, prove Q; if not, fail

'!           ISO'
     cut any choices taken in the current procedure

'\+ :P           ISO'
     goal P is not provable

'?X ^ :P'
     there exists an X such that P is provable (used in 'setof/3' and
     'bagof/3')

'block :P   declaration'
     declaration that predicates specified by P should block until
     sufficiently instantiated

'call(:P)   ISO'
'call(:P,...)   ISO'
     execute P or 'P(...)'

'call_cleanup(:GOAL,:CLEANUP)'
     Executes the procedure call GOAL.  When GOAL succeeds
     determinately, is cut, fails, or raises an exception, CLEANUP is
     executed.

'call_residue_vars(:GOAL,?VARS)'
     Executes the procedure call GOAL.  VARS is unified with the list of
     new variables created during the call that remain unbound and have
     blocked goals or attributes attached to them.

'+ITERATORS do :BODY'
     executes BODY iteratively according to ITERATORS

'fail           ISO'
     fail (start backtracking)

'false           ISO'
     same as 'fail'

'freeze(+VAR,:GOAL)'
     Blocks GOAL until 'nonvar(VAR)' holds.

'if(:P,:Q,:R)'
     for each solution of P that succeeds, prove Q; if none, prove R

'once(:P)           ISO'
     Find the first solution, if any, of goal P.

'otherwise'
     same as true

'repeat           ISO'
     succeed repeatedly on backtracking

'true           ISO'
     succeed

'when(+COND,:GOAL)'
     block GOAL until COND holds


File: sicstus.info,  Node: mpg-top-dat,  Next: mpg-top-deb,  Prev: mpg-top-con,  Up: mpg-top

11.2.5 Database
---------------

'abolish(:F)   ISO'
     abolish the predicate(s) specified by F

'abolish(:F,+O)'
     abolish the predicate(s) specified by F with options O

'assert(:C)'
'assert(:C,-R)'
     clause C is asserted; reference R is returned

'asserta(:C)   ISO'
'asserta(:C,-R)'
     clause C is asserted before existing clauses; reference R is
     returned

'assertz(:C)   ISO'
'assertz(:C,-R)'
     clause C is asserted after existing clauses; reference R is
     returned

'bb_delete(:KEY,-TERM)'
     Delete from the blackboard TERM stored under KEY.

'bb_get(:KEY,-TERM)'
     Get from the blackboard TERM stored under KEY.

'bb_put(:KEY,+TERM)'
     Store TERM under KEY on the blackboard.

'bb_update(:KEY, -OLDTERM, +NEWTERM)'
     Replace OLDTERM by NEWTERM under KEY on the blackboard.

'clause(:P,?Q)   ISO'
'clause(:P,?Q,?R)'
     there is a clause for a dynamic predicate with head P, body Q, and
     reference R

'current_key(?N, ?K)'
     N is the name and K is the key of a recorded term

'dynamic :P   declaration,ISO'
     predicates specified by P are dynamic

'erase(+R)'
     erase the clause or record with reference R

'instance(+R,-T)'
     T is an instance of the clause or term referenced by R

'recorda(+K,+T,-R)'
     make term T the first record under key K; reference R is returned

'recorded(?K,?T,?R)'
     term T is recorded under key K with reference R

'recordz(+K,+T,-R)'
     make term T the last record under key K; reference R is returned

'retract(:C)   ISO'
     erase the first dynamic clause that matches C

'retractall(:H)   ISO'
     erase every clause whose head matches H


File: sicstus.info,  Node: mpg-top-deb,  Next: mpg-top-est,  Prev: mpg-top-dat,  Up: mpg-top

11.2.6 Debugging
----------------

'add_breakpoint(+CONDITIONS, -BID)   development'
     Creates a breakpoint with CONDITIONS and with identifier BID.

'user:breakpoint_expansion(+MACRO, -BODY)   hook,development'
     defines debugger condition macros

'coverage_data(?DATA)   since release 4.2,development'
     DATA is the coverage data accumulated so far

'current_breakpoint(?CONDITIONS, ?BID, ?STATUS, ?KIND, ?TYPE)   development'
     There is a breakpoint with conditions CONDITIONS, identifier BID,
     enabledness STATUS, kind KIND, and type TYPE.

'debug   development'
     switch on debugging

'user:debugger_command_hook(+DCOMMAND,-ACTIONS)   hook,development'
     Allows the interactive debugger to be extended with user-defined
     commands.

'debugging   development'
     display debugging status information

'disable_breakpoints(+BIDS)   development'
     Disables the breakpoints specified by BIDS.

'enable_breakpoints(+BIDS)   development'
     Enables the breakpoints specified by BIDS.

'user:error_exception(+EXCEPTION)   hook'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

'execution_state(+TESTS)   development'
     TESTS are satisfied in the current state of the execution.

'execution_state(+FOCUSCONDITIONS, +TESTS)   development'
     TESTS are satisfied in the state of the execution pointed to by
     FOCUSCONDITIONS.

'leash(+M)   development'
     set the debugger's leashing mode to M

'nodebug   development'
     switch off debugging

'nospy(:P)   development'
     remove spypoints from the procedure(s) specified by P

'nospyall   development'
     remove all spypoints

'notrace   development'
     switch off debugging (same as 'nodebug/0')

'nozip   development'
     switch off debugging (same as 'nodebug/0')

'print_coverage   since release 4.2,development'
'print_coverage(?DATA)   since release 4.2,development'
     The coverage data DATA is displayed in a hierarchical format.  DATA
     defaults to the coverage data accumulated so far.

'print_profile   since release 4.2,development'
'print_profile(?DATA)   since release 4.2,development'
     The profiling data DATA is displayed in a format similar to
     'gprof(1)'.  DATA defaults to the profiling data accumulated so
     far.

'profile_data(?DATA)   since release 4.2,development'
     DATA is the profiling data accumulated so far

'profile_reset   since release 4.2,development'
     All profiling data is reset.

'remove_breakpoints(+BIDS)   development'
     Removes the breakpoints specified by BIDS.

'spy(:P)   development'
'spy(:P,:C)'
     set spypoints on the procedure(s) specified by P with conditions C

'trace   development'
     switch on debugging and start tracing immediately

'unknown(-O,+N)   development'
     Changes action on undefined predicates from O to N.

'user:unknown_predicate_handler(+G,+M,-N)   hook'
     handle for unknown predicates.

'zip   development'
     switch on debugging in zip mode


File: sicstus.info,  Node: mpg-top-est,  Next: mpg-top-fnm,  Prev: mpg-top-deb,  Up: mpg-top

11.2.7 Errors and Exceptions
----------------------------

'abort'
     abort execution of the program; return to current break level

'break'
     start a new break-level to interpret commands from the user

'catch(:P,?E,:H)   ISO'
     specify a handler H for any exception E arising in the execution of
     the goal P

'user:error_exception(+EXCEPTION)   hook,development'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

'goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

'halt   ISO'
'halt(C)   ISO'
     exit from Prolog with exit code C

'on_exception(?E,:P,:H)'
     specify a handler H for any exception E arising in the execution of
     the goal P

'raise_exception(+E)'
     raise exception E

'throw(+E)   ISO'
     raise exception E

'unknown(?OLDVALUE, ?NEWVALUE)   development'
     access the 'unknown' Prolog flag and print a message

'user:unknown_predicate_handler(+GOAL, +MODULE, -NEWGOAL)   hook'
     tell Prolog to call 'MODULE:NEWGOAL' if 'MODULE:GOAL' is undefined


File: sicstus.info,  Node: mpg-top-fnm,  Next: mpg-top-fsh,  Prev: mpg-top-est,  Up: mpg-top

11.2.8 Filename Manipulation
----------------------------

'absolute_file_name(+R,-A)   hookable'
'absolute_file_name(+R,-A,+O)   hookable'
     expand relative filename R to absolute file name A using options
     specified in O

'user:file_search_path(+F,-D)   hook'
     directory D is included in file search path F

'user:library_directory(-D)   hook'
     D is a library directory that will be searched


File: sicstus.info,  Node: mpg-top-fsh,  Next: mpg-top-fin,  Prev: mpg-top-fnm,  Up: mpg-top

11.2.9 File and Stream Handling
-------------------------------

'byte_count(+S,-N)'
     N is the number of bytes read/written on binary stream S

'character_count(+S,-N)'
     N is the number of characters read/written on text stream S

'close(+F)   ISO'
'close(+F,+O)   ISO'
     close file or stream F with options O

'current_input(-S)   ISO'
     S is the current input stream

'current_output(-S)   ISO'
     S is the current output stream

'current_stream(?F,?M,?S)'
     S is a stream open on file F in mode M

'line_count(+S,-N)'
     N is the number of lines read/written on text stream S

'line_position(+S,-N)'
     N is the number of characters read/written on the current line of
     text stream S

'open(+F,+M,-S)   ISO'
'open(+F,+M,-S,+O)   ISO'
     file F is opened in mode M, options O, returning stream S

'open_null_stream(+S)'
     new output to text stream S goes nowhere

'prompt(-O,+N)'
     queries or changes the prompt string of the current input stream

'see(+F)'
     make file F the current input stream

'seeing(-N)'
     the current input stream is named N

'seek(+S,+O,+M,+N)'
     seek to an arbitrary byte position on the stream S

'seen'
     close the current input stream

'set_input(+S)   ISO'
     select S as the current input stream

'set_output(+S)   ISO'
     select S as the current output stream

'set_stream_position(+S,+P)   ISO'
     P is the new position of stream S

'stream_code(?S,?C)'
     Converts between Prolog and C representations of a stream

'stream_position(+S,-P)'
     P is the current position of stream S

'stream_position_data(?FIELD,?POSITION,?DATA)'
     The FIELD field of the stream position term POSITION is DATA.

'stream_property(?STREAM, ?PROPERTY)   ISO'
     Stream STREAM has property PROPERTY.

'tell(+F)'
     make file F the current output stream

'telling(-N)'
     to file N

'told'
     close the current output stream


File: sicstus.info,  Node: mpg-top-fin,  Next: mpg-top-gru,  Prev: mpg-top-fsh,  Up: mpg-top

11.2.10 Foreign Interface
-------------------------

'foreign(+F,-P)   hook'
'foreign(+F,-L,-P)   hook'
     function F in language L is attached to P

'foreign_resource(+R,-L)   hook'
     resource R defines foreign functions in list L

'load_foreign_resource(+R)   hookable'
     load foreign resource R

'stream_code(?S,?C)'
     Converts between Prolog and C representations of a stream

'unload_foreign_resource(+R)'
     unload foreign resource R


File: sicstus.info,  Node: mpg-top-gru,  Next: mpg-top-hok,  Prev: mpg-top-fin,  Up: mpg-top

11.2.11 Grammar Rules
---------------------

':HEAD --> :BODY'
     A possible form for HEAD is BODY

'expand_term(+T,-X)   hookable'
     term T expands to term X using 'user:term_expansion/6' or grammar
     rule expansion

'phrase(:P, -L)'
'phrase(:P, ?L, ?R)'
     R or the empty list is what remains of list L after phrase P has
     been found

'user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)   hook'
     Overrides or complements the standard transformations to be done by
     'expand_term/2'.


File: sicstus.info,  Node: mpg-top-hok,  Next: mpg-top-lis,  Prev: mpg-top-gru,  Up: mpg-top

11.2.12 Hook Predicates
-----------------------

'user:breakpoint_expansion(+MACRO, -BODY)   hook,development'
     defines debugger condition macros

'user:debugger_command_hook(+DCOMMAND,-ACTIONS)   hook,development'
     Allows the interactive debugger to be extended with user-defined
     commands.

'user:error_exception(=EXCEPTION)   hook'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

'user:file_search_path(+F,-D)   hook'
     directory D is included in file search path F

'foreign(+F,-P)'
'foreign(+F,-L,-P)'
     Describes the interface between Prolog and the foreign ROUTINE

'foreign_resource(+R,-L)'
     resource R defines foreign functions in list L

'user:generate_message_hook(+M,?S0,?S)   hook'
     A way for the user to override the call to
     ''SU_messages':generate_message/3' in 'print_message/2'.

'goal_expansion(+TERM1, +LAYOUT1, +MODULE, -TERM2, -LAYOUT2)   hook'
     Defines transformations on goals while clauses are being compiled
     or asserted, and during meta-calls.

'user:library_directory(-D)   hook'
     D is a library directory that will be searched

'user:message_hook(+S,+M,+L)   hook'
     Overrides the call to 'print_message_lines/3' in 'print_message/2'.

'user:portray(+T)'
     A way for the user to over-ride the default behavior of 'print/1'.

'user:portray_message(+S,+M)   hook'
     Tells 'print_message/2' what to do.

'user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)   hook'
     Called by 'ask_query/4' before processing the query.  If this
     predicate succeeds, then it is assumed that the query has been
     processed and nothing further is done.

'user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

'user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

'user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.

'user:runtime_entry(+M)   hook'
     This predicate is called upon start-up and exit of stand alone
     applications.

'user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)   hook'
     Overrides or complements the standard transformations to be done by
     'expand_term/2'.

'user:unknown_predicate_handler(+G,+M,-N)   hook'
     hook to trap calls to unknown predicates


File: sicstus.info,  Node: mpg-top-lis,  Next: mpg-top-lod,  Prev: mpg-top-hok,  Up: mpg-top

11.2.13 List Processing
-----------------------

'?T =.. ?L   ISO'
     the functor and arguments of term T comprise the list L

'append(?A,?B,?C)'
     the list C is the concatenation of lists A and B

'keysort(+L,-S)   ISO'
     the list L sorted by key yields S

'length(?L,?N)'
     the length of list L is N

'member(?X,?L)'
     X is a member of L

'memberchk(+X,+L)'
     X is a member of L

'nonmember(+X,+L)'
     X is not a member of L

'sort(+L,-S)   ISO'
     sorting the list L into order yields S


File: sicstus.info,  Node: mpg-top-lod,  Next: mpg-top-mem,  Prev: mpg-top-lis,  Up: mpg-top

11.2.14 Loading Programs
------------------------

'[]'
'[:F|+FS]'
     same as 'load_files([F|FS])'

'block :P   declaration'
     predicates specified by P should block until sufficiently
     instantiated

'compile(:F)'
     load compiled clauses from files F

'consult(:F)'
'reconsult(:F)'
     load interpreted clauses from files F

'expand_term(+T,-X)   hookable'
     term T expands to term X using 'user:term_expansion/6' or grammar
     rule expansion

'goal_expansion(+TERM1, +LAYOUT1, +MODULE, -TERM2, -LAYOUT2)   hook'
     Defines transformations on goals while clauses are being compiled
     or asserted, and during meta-calls.

'discontiguous :P   declaration, ISO'
     clauses of predicates P do not have to appear contiguously

'dynamic :P   declaration, ISO'
     predicates specified by P are dynamic

'elif(:GOAL)   declaration'
     Provides an alternative branch in a sequence of conditional
     compilation directives.

'else   declaration'
     Provides an alternative branch in a sequence of conditional
     compilation directives.

'endif   declaration'
     Terminates a sequence of conditional compilation directives.

'ensure_loaded(:F)   ISO'
     load F if not already loaded

'if(:GOAL)   declaration'
     Starts a sequence of conditional compilation directives for
     conditionally including parts of a source file.

'include(+F)   declaration, ISO'
     include the source file(s) F verbatim

'initialization :G   declaration, ISO'
     declares G to be run when program is started

'load_files(:F)'
'load_files(:F,+O)'
     load files according to options O

'meta_predicate :P   declaration'
     declares predicates P that are dependent on the module from which
     they are called

'mode :P   declaration'
     NO-OP: document calling modes for predicates specified by P

'module(+M,+L)   declaration'
'module(+M,+L,+O)   declaration'
     module M exports predicates in L, options O

'multifile :P   declaration, ISO'
     the clauses for P are in more than one file

'public :P   declaration'
     NO-OP: declare predicates specified by P public

'restore(+F)'
     restore the state saved in file F

'user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)   hook'
     Overrides or complements the standard transformations to be done by
     'expand_term/2'.

'use_module(:F)'
'use_module(:F,+I)'
     import the procedure(s) I from the module-file F

'use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary

'volatile :P   declaration'
     predicates specified by P are not to be included in saves


File: sicstus.info,  Node: mpg-top-mem,  Next: mpg-top-msg,  Prev: mpg-top-lod,  Up: mpg-top

11.2.15 Memory
--------------

'garbage_collect'
     force an immediate garbage collection

'garbage_collect_atoms'
     garbage collect atom space

'statistics'
     display various execution statistics

'statistics(?K,?V)'
     the execution statistic with key K has value V

'trimcore'
     reduce free stack space to a minimum


File: sicstus.info,  Node: mpg-top-msg,  Next: mpg-top-mod,  Prev: mpg-top-mem,  Up: mpg-top

11.2.16 Messages and Queries
----------------------------

'ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)   hookable'
     Prints the question QUERY, then reads and processes user input
     according to QUERYCLASS, and returns the result of the processing,
     the abstract answer term ANSWER.  The HELP message is printed in
     case of invalid input.

'user:message_hook(+M,+S,+L)   hook'
     intercept the printing of a message

''SU_messages':generate_message(+M,?SO,?S)   extendible'
     determines the mapping from a message term into a sequence of lines
     of text to be printed

'user:generate_message_hook(+M,?S0,?S)   hook'
     intercept message before it is given to
     ''SU_messages':generate_message/3'

'goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

'user:portray_message(+SEVERITY,+MESSAGE)   hook'
     Tells 'print_message/2' what to do.

'print_message(+S,+M)   hookable'
     print a message M of severity S

'print_message_lines(+S,+P,+L)'
     print the message lines L to stream S with prefix P

''SU_messages':query_abbreviation(+T,-P)   extendible'
     specifies one letter abbreviations for responses to queries from
     the Prolog system

'user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)   hook'
     Called by 'ask_query/4' before processing the query.  If this
     predicate succeeds, then it is assumed that the query has been
     processed and nothing further is done.

''SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   extendible'
     Access the parameters of a given QUERYCLASS.

'user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

''SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)   extendible'
     Implements the input phase of query processing.

'user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

''SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   extendible'
     Implements the mapping phase of query processing.

'user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   hook'
     Provides the user with a method of overriding the call to
     ''SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.


File: sicstus.info,  Node: mpg-top-mod,  Next: mpg-top-sta,  Prev: mpg-top-msg,  Up: mpg-top

11.2.17 Modules
---------------

'current_module(?M)'
     M is the name of a current module

'current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

'meta_predicate :P   declaration'
     declares predicates P that are dependent on the module from which
     they are called

'module(+M,+L)   declaration'
'module(+M,+L,+O)   declaration'
     declaration that module M exports predicates in L, options O

'save_modules(+L,+F)'
     save the modules specifed in L into file F

'set_module(+M)'
     make M the type-in module

'use_module(:F)'
     import the module-file(s) F, loading them if necessary

'use_module(:F,+I)'
     import the procedure(s) I from the module-file F

'use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary


File: sicstus.info,  Node: mpg-top-sta,  Next: mpg-top-eqs,  Prev: mpg-top-mod,  Up: mpg-top

11.2.18 Program State
---------------------

'current_atom(?A)'
     backtrack through all atoms

'current_module(?M)'
     M is the name of a current module

'current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

'current_predicate(:A/?N)   ISO'
'current_predicate(?A,:P)'
     A is the name of a predicate with most general goal P and arity N

'current_prolog_flag(?F,?V)   ISO'
     V is the current value of Prolog flag F

'listing'
     list all dynamic procedures in the type-in module

'listing(:P)'
     list the dynamic procedure(s) specified by P

'predicate_property(:P,?PROP)'
     PROP is a property of the loaded predicate P

'prolog_flag(?F,?V)'
     V is the current value of Prolog flag F

'prolog_flag(+F,=O,+N)'
     O is the old value of Prolog flag F; N is the new value

'prolog_load_context(?K,?V)'
     find out the context of the current load

'set_module(+M)'
     make M the type-in module

'set_prolog_flag(+F,+N)   ISO'
     N is the new value of Prolog flag F

'source_file(?F)'
     F is a source file that has been loaded into the database

'source_file(:P,?F)'
     P is a predicate defined in the loaded file F

'unknown(-O,+N)   development'
     Changes action on undefined predicates from O to N.


File: sicstus.info,  Node: mpg-top-eqs,  Next: mpg-top-tcm,  Prev: mpg-top-sta,  Up: mpg-top

11.2.19 Saving Programs
-----------------------

'initialization :G   declaration,ISO'
     declares G to be run when program is started

'load_files(:F)'
'load_files(:F,+O)'
     load files according to options O

'user:runtime_entry(+S)   hook'
     entry point for a runtime system

'save_files(+L,+F)'
     saves the modules, predicates, clauses and directives in the given
     files L into file F

'save_modules(+L,+F)'
     save the modules specifed in L into file F

'save_predicates(:L,+F)'
     save the predicates specified in L into file F

'save_program(+F)'
'save_program(+F,:G)'
     save all Prolog data into file F with startup goal G

'volatile :P   declaration'
     declares predicates specified by P to not be included in saves.


File: sicstus.info,  Node: mpg-top-tcm,  Next: mpg-top-tha,  Prev: mpg-top-eqs,  Up: mpg-top

11.2.20 Term Comparison
-----------------------

'compare(-C,+X,+Y)   ISO'
     C is the result of comparing terms X and Y

'+X == +Y   ISO'
     terms X and Y are strictly identical

'+X \== +Y   ISO'
     terms X and Y are not strictly identical

'+X @< +Y   ISO'
     term X precedes term Y in standard order for terms

'+X @>= +Y   ISO'
     term X follows or is identical to term Y in standard order for
     terms

'+X @> +Y   ISO'
     term X follows term Y in standard order for terms

'+X @=< +Y   ISO'
     term X precedes or is identical to term Y in standard order for
     terms


File: sicstus.info,  Node: mpg-top-tha,  Next: mpg-top-tio,  Prev: mpg-top-tcm,  Up: mpg-top

11.2.21 Term Handling
---------------------

'?T =.. ?L   ISO'
     the functor and arguments of term T comprise the list L

'?X = ?Y   ISO'
     terms X and Y are unified

'+X \= +Y   ISO'
     terms X and Y no not unify

'?=(+X,+Y)'
     X and Y are either strictly identical or do not unify

'acyclic_term(+T)   since release 4.3, ISO'
     term T is a finite (acyclic) term

'arg(+N,+T,-A)   ISO'
     the Nth argument of term T is A

'atom_chars(?A,?L)   ISO'
     A is the atom containing the character atoms in list L

'atom_codes(?A,?L)   ISO'
     A is the atom containing the characters in code-list L

'atom_concat(?ATOM1,?ATOM2,?ATOM12)   ISO'
     Atom ATOM1 concatenated with ATOM2 gives ATOM12.

'atom_length(+ATOM,-LENGTH)   ISO'
     LENGTH is the number of characters of the atom ATOM.

'char_code(?CHAR,?CODE)   ISO'
     CODE is the character code of the one-char atom CHAR.

'copy_term(+T,-C)   ISO'
     C is a copy of T in which all variables have been replaced by new
     variables

'copy_term(+T,-C,-G)'
     C is a copy of T in which all variables have been replaced by new
     variables, and G is a goal for reinstating any attributes in C

'create_mutable(+DATUM,-MUTABLE)'
     MUTABLE is a new mutable term with current value DATUM.

'dif(+X,+Y)'
     X and Y are constrained to be different.

'frozen(+VAR,-GOAL)'
     The goal GOAL is blocked on the variable VAR.

'functor(?T,?F,?N)   ISO'
     the principal functor of term T has name F and arity N

'get_mutable(-DATUM,+MUTABLE)'
     The current value of the mutable term MUTABLE is DATUM.

'name(?A,?L)   deprecated'
     the code-list of atom or number A is L

'number_chars(?N,?L)   ISO'
     N is the numeric representation of list of character atoms L

'number_codes(?N,?L)   ISO'
     N is the numeric representation of code-list L

'numbervars(+T,+M,-N)'
     number the variables in term T from M to N-1

'sub_atom(+ATOM,?BEFORE,?LENGTH,?AFTER,?SUBATOM)   ISO'
     The characters of SUBATOM form a sublist of the characters of ATOM,
     such that the number of characters preceding SUBATOM is BEFORE, the
     number of characters after SUBATOM is AFTER, and the length of
     SUBATOM is LENGTH.

'subsumes_term(General,Specific)   since release 4.3, ISO'
     SPECIFIC is an instance of GENERAL

'term_variables(+TERM,-VARIABLES)   since release 4.3, ISO'
     VARIABLES is the set of variables that occur in TERM

'unify_with_occurs_check(?X,?Y)   ISO'
     True if X and Y unify to a finite (acyclic) term.


File: sicstus.info,  Node: mpg-top-tio,  Next: mpg-top-typ,  Prev: mpg-top-tha,  Up: mpg-top

11.2.22 Term I/O
----------------

'char_conversion(+INCHAR, +OUTCHAR)   ISO'
     The mapping of INCHAR to OUTCHAR is added to the
     character-conversion mapping.

'current_char_conversion(?INCHAR, ?OUTCHAR)   ISO'
     INCHAR is mapped to OUTCHAR in the current character-conversion
     mapping.

'current_op(?P,?T,?A)   ISO'
     atom A is an operator of type T with precedence P

'display(+T)'
     write term T to the user output stream in functional notation

'format(+C,:A)'
'format(+S,+C,:A)'
     write arguments A on stream S according to control string C

'op(+P,+T,+A)   ISO'
     make atom A an operator of type T with precedence P

'user:portray(+T)   hook'
     tell 'print/[1,2]' and 'write_term/[2,3]' what to do

'portray_clause(+C)'
'portray_clause(+S,+C)'
     write clause C to the stream S

'print(+T)   hookable'
'print(+S,+T)   hookable'
     display the term T on stream S using 'user:portray/1' or 'write/2'

'read(-T)   ISO'
'read(+S,-T)   ISO'
     read term T from stream S

'read_term(-T,+O)   ISO'
'read_term(+S,-T,+O)   ISO'
     read T from stream S according to options O

'write(+T)   ISO'
'write(+S,+T)   ISO'
     write term T on stream S

'write_canonical(+T)   ISO'
'write_canonical(+S,+T)   ISO'
     write term T on stream S so that it can be read back by
     'read/[1,2]'

'writeq(+T)   ISO'
'writeq(+S,+T)   ISO'
     write term T on stream S, quoting atoms where necessary

'write_term(+T,+O)   hookable,ISO'
'write_term(+S,+T,+O)   hookable,ISO'
     writes T to S according to options O


File: sicstus.info,  Node: mpg-top-typ,  Prev: mpg-top-tio,  Up: mpg-top

11.2.23 Type Tests
------------------

'atom(+T)   ISO'
     term T is an atom

'atomic(+T)   ISO'
     term T is an atom or a number

'callable(+T)   ISO'
     T is an atom or a compound term

'compound(+T)   ISO'
     T is a compound term

'db_reference(+X)   since release 4.1'
     X is a db_reference

'float(+N)   ISO'
     N is a floating-point number

'ground(+T)   ISO'
     term T is a nonvar, and all substructures are nonvar

'integer(+T)   ISO'
     term T is an integer

'mutable(+X)'
     X is a mutable term

'nonvar(+T)   ISO'
     term T is one of atom, number, compound (that is, T is
     instantiated)

'number(+N)   ISO'
     N is an integer or a float

'simple(+T)'
     T is not a compound term; it is either atomic or a var

'var(+T)   ISO'
     term T is a variable (that is, T is uninstantiated)


File: sicstus.info,  Node: mpg-bpr,  Prev: mpg-top,  Up: Prolog Reference Pages

11.3 Built-In Predicates
========================

The following reference pages, alphabetically arranged, describe the
SICStus Prolog built-in predicates.

   For a functional grouping of these predicates including brief
descriptions, see *note mpg-top::.

   In many cases, the heading of a reference page, as well as an entry
in a list of built-in predicates, will be annotated with keywords.
These annotations are defined in *note mpg-ref-cat::.

   Further information about categories of predicates and arguments,
mode annotations, and the conventions observed in the reference pages is
found in *note mpg-ref::.

* Menu:

* mpg-ref-cut:: !/0
* mpg-ref-and:: ,/2
* mpg-ref-if_then:: ->/2
* mpg-ref-or:: ;/2
* mpg-ref-less_than:: </2
* mpg-ref-univ:: =../2
* mpg-ref-unify:: =/2
* mpg-ref-equal_to:: =:=/2
* mpg-ref-not_greater_than:: =</2
* mpg-ref-term_equal_to:: ==/2
* mpg-ref-not_equal_to:: =\=/2
* mpg-ref-greater_than:: >/2
* mpg-ref-not_less_than:: >=/2
* mpg-ref-term_unify_decided:: ?=/2
* mpg-ref-term_less_than:: @</2
* mpg-ref-term_not_greater_than:: @=</2
* mpg-ref-term_greater_than:: @>/2
* mpg-ref-term_not_less_than:: @>=/2
* mpg-ref-not_provable:: \+/1
* mpg-ref-not_unifiable:: \=/2
* mpg-ref-term_not_equal_to:: \==/2
* mpg-ref-exists:: ^/2
* mpg-ref-abolish:: abolish/[1,2]
* mpg-ref-abort:: abort/0
* mpg-ref-absolute_file_name:: absolute_file_name/[2,3]
* mpg-ref-acyclic_term:: acyclic_term/1
* mpg-ref-add_breakpoint:: add_breakpoint/2
* mpg-ref-append:: append/3
* mpg-ref-arg:: arg/3
* mpg-ref-ask_query:: ask_query/4
* mpg-ref-assert:: assert/[1,2]
* mpg-ref-asserta:: asserta/[1,2]
* mpg-ref-assertz:: assertz/[1,2]
* mpg-ref-at_end_of_line:: at_end_of_line/[0,1]
* mpg-ref-at_end_of_stream:: at_end_of_stream/[0,1]
* mpg-ref-atom:: atom/1
* mpg-ref-atom_chars:: atom_chars/2
* mpg-ref-atom_codes:: atom_codes/2
* mpg-ref-atom_concat:: atom_concat/3
* mpg-ref-atom_length:: atom_length/2
* mpg-ref-atomic:: atomic/1
* mpg-ref-bagof:: bagof/3
* mpg-ref-bb_delete:: bb_delete/2
* mpg-ref-bb_get:: bb_get/2
* mpg-ref-bb_put:: bb_put/2
* mpg-ref-bb_update:: bb_update/3
* mpg-ref-block:: block/1
* mpg-ref-break:: break/0
* mpg-ref-breakpoint_expansion:: breakpoint_expansion/2
* mpg-ref-byte_count:: byte_count/2
* mpg-ref-call:: call/[1,2,...,255]
* mpg-ref-call_cleanup:: call_cleanup/2
* mpg-ref-call_residue_vars:: call_residue_vars/2
* mpg-ref-callable:: callable/1
* mpg-ref-catch:: catch/3
* mpg-ref-char_code:: char_code/2
* mpg-ref-char_conversion:: char_conversion/2
* mpg-ref-character_count:: character_count/2
* mpg-ref-clause:: clause/[2,3]
* mpg-ref-close:: close/[1,2]
* mpg-ref-compare:: compare/3
* mpg-ref-compile:: compile/1
* mpg-ref-compound:: compound/1
* mpg-ref-consult:: consult/1
* mpg-ref-copy_term:: copy_term/[2,3]
* mpg-ref-coverage_data:: coverage_data/1
* mpg-ref-create_mutable:: create_mutable/2
* mpg-ref-current_atom:: current_atom/1
* mpg-ref-current_breakpoint:: current_breakpoint/5
* mpg-ref-current_char_conversion:: current_char_conversion/2
* mpg-ref-current_input:: current_input/1
* mpg-ref-current_key:: current_key/2
* mpg-ref-current_module:: current_module/[1,2]
* mpg-ref-current_op:: current_op/3
* mpg-ref-current_output:: current_output/1
* mpg-ref-current_predicate:: current_predicate/[1,2]
* mpg-ref-current_prolog_flag:: current_prolog_flag/2
* mpg-ref-current_stream:: current_stream/3
* mpg-ref-db_reference:: db_reference/1
* mpg-ref-debug:: debug/0
* mpg-ref-debugger_command_hook:: debugger_command_hook/2
* mpg-ref-debugging:: debugging/0
* mpg-ref-dif:: dif/2
* mpg-ref-disable_breakpoints:: disable_breakpoints/1
* mpg-ref-discontiguous:: discontiguous/1
* mpg-ref-display:: display/1
* mpg-ref-do:: do/2
* mpg-ref-dynamic:: dynamic/1
* mpg-ref-enable_breakpoints:: enable_breakpoints/1
* mpg-ref-ensure_loaded:: ensure_loaded/1
* mpg-ref-erase:: erase/1
* mpg-ref-error_exception:: error_exception/1
* mpg-ref-execution_state:: execution_state/[1,2]
* mpg-ref-expand_term:: expand_term/2
* mpg-ref-fail:: fail/0
* mpg-ref-false:: false/0
* mpg-ref-file_search_path:: file_search_path/2
* mpg-ref-findall:: findall/[3,4]
* mpg-ref-float:: float/1
* mpg-ref-flush_output:: flush_output/[0,1]
* mpg-ref-foreign:: foreign/[2,3]
* mpg-ref-foreign_resource:: foreign_resource/2
* mpg-ref-format:: format/[2,3]
* mpg-ref-freeze:: freeze/2
* mpg-ref-frozen:: frozen/2
* mpg-ref-functor:: functor/3
* mpg-ref-garbage_collect:: garbage_collect/0
* mpg-ref-garbage_collect_atoms:: garbage_collect_atoms/0
* mpg-ref-generate_message:: generate_message/3
* mpg-ref-generate_message_hook:: generate_message_hook/3
* mpg-ref-get_byte:: get_byte/[1,2]
* mpg-ref-get_char:: get_char/[1,2]
* mpg-ref-get_code:: get_code/[1,2]
* mpg-ref-get_mutable:: get_mutable/2
* mpg-ref-goal_expansion:: goal_expansion/5
* mpg-ref-goal_source_info:: goal_source_info/3
* mpg-ref-ground:: ground/1
* mpg-ref-halt:: halt/[0,1]
* mpg-ref-if:: if/3
* mpg-ref-include:: include/1
* mpg-ref-initialization:: initialization/1
* mpg-ref-instance:: instance/2
* mpg-ref-integer:: integer/1
* mpg-ref-is:: is/2
* mpg-ref-keysort:: keysort/2
* mpg-ref-leash:: leash/1
* mpg-ref-length:: length/2
* mpg-ref-library_directory:: library_directory/1
* mpg-ref-line_count:: line_count/2
* mpg-ref-line_position:: line_position/2
* mpg-ref-listing:: listing/[0,1]
* mpg-ref-load_files:: load_files/[1,2]
* mpg-ref-load_foreign_resource:: load_foreign_resource/1
* mpg-ref-member:: member/2
* mpg-ref-memberchk:: memberchk/2
* mpg-ref-message_hook:: message_hook/3
* mpg-ref-meta_predicate:: meta_predicate/1
* mpg-ref-mode:: mode/1
* mpg-ref-module:: module/[2,3]
* mpg-ref-multifile:: multifile/1
* mpg-ref-mutable:: mutable/1
* mpg-ref-name:: name/2
* mpg-ref-nl:: nl/[0,1]
* mpg-ref-nodebug:: nodebug/0
* mpg-ref-nonmember:: nonmember/2
* mpg-ref-nonvar:: nonvar/1
* mpg-ref-nospy:: nospy/1
* mpg-ref-nospyall:: nospyall/0
* mpg-ref-notrace:: notrace/0
* mpg-ref-nozip:: nozip/0
* mpg-ref-number:: number/1
* mpg-ref-number_chars:: number_chars/2
* mpg-ref-number_codes:: number_codes/2
* mpg-ref-numbervars:: numbervars/3
* mpg-ref-on_exception:: on_exception/3
* mpg-ref-once:: once/1
* mpg-ref-op:: op/3
* mpg-ref-open:: open/[3,4]
* mpg-ref-open_null_stream:: open_null_stream/1
* mpg-ref-otherwise:: otherwise/0
* mpg-ref-peek_byte:: peek_byte/[1,2]
* mpg-ref-peek_char:: peek_char/[1,2]
* mpg-ref-peek_code:: peek_code/[1,2]
* mpg-ref-phrase:: phrase/[2,3]
* mpg-ref-portray:: portray/1
* mpg-ref-portray_clause:: portray_clause/[1,2]
* mpg-ref-portray_message:: portray_message/2
* mpg-ref-predicate_property:: predicate_property/2
* mpg-ref-print:: print/[1,2]
* mpg-ref-print_coverage:: print_coverage/[0,1]
* mpg-ref-print_message:: print_message/2
* mpg-ref-print_message_lines:: print_message_lines/3
* mpg-ref-print_profile:: print_profile/[0,1]
* mpg-ref-profile_data:: profile_data/1
* mpg-ref-profile_reset:: profile_reset/0
* mpg-ref-prolog_flag:: prolog_flag/[2,3]
* mpg-ref-prolog_load_context:: prolog_load_context/2
* mpg-ref-prompt:: prompt/2
* mpg-ref-public:: public/1
* mpg-ref-put_byte:: put_byte/[1,2]
* mpg-ref-put_char:: put_char/[1,2]
* mpg-ref-put_code:: put_code/[1,2]
* mpg-ref-query_abbreviation:: query_abbreviation/3
* mpg-ref-query_class:: query_class/5
* mpg-ref-query_class_hook:: query_class_hook/5
* mpg-ref-query_hook:: query_hook/6
* mpg-ref-query_input:: query_input/3
* mpg-ref-query_input_hook:: query_input_hook/3
* mpg-ref-query_map:: query_map/4
* mpg-ref-query_map_hook:: query_map_hook/4
* mpg-ref-raise_exception:: raise_exception/1
* mpg-ref-read:: read/[1,2]
* mpg-ref-read_line:: read_line/[1,2]
* mpg-ref-read_term:: read_term/[2,3]
* mpg-ref-reconsult:: reconsult/1
* mpg-ref-recorda:: recorda/3
* mpg-ref-recorded:: recorded/3
* mpg-ref-recordz:: recordz/3
* mpg-ref-remove_breakpoints:: remove_breakpoints/1
* mpg-ref-repeat:: repeat/0
* mpg-ref-restore:: restore/1
* mpg-ref-retract:: retract/1
* mpg-ref-retractall:: retractall/1
* mpg-ref-save_files:: save_files/2
* mpg-ref-save_modules:: save_modules/2
* mpg-ref-save_predicates:: save_predicates/2
* mpg-ref-save_program:: save_program/[1,2]
* mpg-ref-see:: see/1
* mpg-ref-seeing:: seeing/1
* mpg-ref-seek:: seek/4
* mpg-ref-seen:: seen/0
* mpg-ref-set_input:: set_input/1
* mpg-ref-set_module:: set_module/1
* mpg-ref-set_output:: set_output/1
* mpg-ref-set_prolog_flag:: set_prolog_flag/2
* mpg-ref-set_stream_position:: set_stream_position/2
* mpg-ref-setof:: setof/3
* mpg-ref-simple:: simple/1
* mpg-ref-skip_byte:: skip_byte/[1,2]
* mpg-ref-skip_char:: skip_char/[1,2]
* mpg-ref-skip_code:: skip_code/[1,2]
* mpg-ref-skip_line:: skip_line/[0,1]
* mpg-ref-sort:: sort/2
* mpg-ref-source_file:: source_file/[1,2]
* mpg-ref-spy:: spy/[1,2]
* mpg-ref-statistics:: statistics/[0,2]
* mpg-ref-stream_code:: stream_code/2
* mpg-ref-stream_position:: stream_position/2
* mpg-ref-stream_position_data:: stream_position_data/3
* mpg-ref-stream_property:: stream_property/2
* mpg-ref-sub_atom:: sub_atom/5
* mpg-ref-subsumes_term:: subsumes_term/2
* mpg-ref-tell:: tell/1
* mpg-ref-telling:: telling/1
* mpg-ref-term_expansion:: term_expansion/6
* mpg-ref-term_variables:: term_variables/2
* mpg-ref-throw:: throw/1
* mpg-ref-told:: told/0
* mpg-ref-trace:: trace/0
* mpg-ref-trimcore:: trimcore/0
* mpg-ref-true:: true/0
* mpg-ref-unify_with_occurs_check:: unify_with_occurs_check/2
* mpg-ref-unknown:: unknown/2
* mpg-ref-unknown_predicate_handler:: unknown_predicate_handler/3
* mpg-ref-unload_foreign_resource:: unload_foreign_resource/1
* mpg-ref-update_mutable:: update_mutable/2
* mpg-ref-use_module:: use_module/[1,2,3]
* mpg-ref-var:: var/1
* mpg-ref-volatile:: volatile/1
* mpg-ref-when:: when/2
* mpg-ref-write:: write/[1,2]
* mpg-ref-write_canonical:: write_canonical/[1,2]
* mpg-ref-write_term:: write_term/[2,3]
* mpg-ref-writeq:: writeq/[1,2]
* mpg-ref-zip:: zip/0


File: sicstus.info,  Node: mpg-ref-abolish,  Next: mpg-ref-abort,  Prev: mpg-ref-exists,  Up: mpg-bpr

11.3.1 'abolish/[1,2]'   ISO
----------------------------

Synopsis
--------

'abolish(+PREDICATES)'

   'abolish(+PREDICATES, +OPTIONS)'

   Removes procedures from the Prolog database.

Arguments
---------

:PREDICATES
     "pred_spec" or "pred_spec_tree"

     A predicate specification, or a list of such.

     Note that the default is to only allow a single predicate
     specification, see 'tree/1' option below.

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following:

     'force(BOOLEAN)'
          Specifies whether SICStus Prolog is to abolish the predicate
          even if it is static ('true'), or only if it is dynamic
          ('false').  The latter is the default.

     'tree(BOOLEAN)'
          Specifies whether the first argument should be a
          "pred_spec_tree" ('true'), or a "pred_spec" ('false').  The
          latter is the default.

Description
-----------

Removes all procedures specified.  After this command is executed the
current program functions as if the named procedures had never existed.
That is, in addition to removing all the clauses for each specified
procedure, 'abolish/[1,2]' removes any properties that the procedure
might have had, such as being dynamic or multifile.  You cannot abolish
built-in procedures.

   It is important to note that 'retract/1', 'retractall/1', and
'erase/1' only remove clauses, and only of dynamic procedures.  They
don't remove the procedures themselves or their properties properties
(such as being dynamic or multifile).  'abolish/[1,2]', on the other
hand, remove entire procedures along with any clauses and properties.

   The procedures that are abolished do not become invisible to a
currently running procedure.

   Space occupied by abolished procedures is reclaimed.  The space
occupied by the procedures is reclaimed.

   Procedures must be defined in the source module before they can be
abolished.  An attempt to abolish a procedure that is imported into the
source module will cause a permission error.  Using a module prefix,
'M:', procedures in any module may be abolished.

   Abolishing a foreign procedure destroys only the link between that
Prolog procedure and the associated foreign code.  The foreign code that
was loaded remains in memory.  This is necessary because Prolog cannot
tell which subsequently-loaded foreign files may have links to the
foreign code.  The Prolog part of the foreign procedure is destroyed and
reclaimed.

   Specifying an undefined procedure is not an error.

Exceptions
----------

'instantiation_error'
     if one of the arguments is not instantiated enough.

'type_error'
     PREDICATES is not a valid tree of predicate specifications, or a
     NAME is not an atom or an ARITY not an integer.

'domain_error'
     if an ARITY is specified as an integer outside the range 0-255.

'permission_error'
     if a specified procedure is built-in, or imported into the source
     module, or static when 'force(true)' is not in effect.

Examples
--------

     | ?- [user].
     % compiling user...
     | foo(1,2).
     | ^D
     % compiled user in module user, 10 msec -80 bytes
     yes
     | ?- abolish(foo).
     ! Type error in argument 1 of abolish/1
     ! expected pred_spec, but found foo
     ! goal:  abolish(user:foo)
     | ?- abolish(foo,[tree(true)]).
     ! Permission error: cannot abolish static user:foo/2
     ! goal:  abolish(user:foo,[tree(true)])
     | ?- abolish(foo/2).
     ! Permission error: cannot abolish static user:foo/2
     ! goal:  abolish(user:foo/2)
     | ?- abolish(foo/2,[force(true)]).
     yes
     % source_info

Comments
--------

'abolish/1' is part of the ISO Prolog standard; 'abolish/2' is not.

See Also
--------

'dynamic/1', 'erase/1', 'retract/1', 'retractall/1'.


File: sicstus.info,  Node: mpg-ref-abort,  Next: mpg-ref-absolute_file_name,  Prev: mpg-ref-abolish,  Up: mpg-bpr

11.3.2 'abort/0'
----------------

Synopsis
--------

'abort'

   Abandons the current execution and returns to the beginning of the
current break level or terminates the enclosing query, whichever is
closest.

Description
-----------

Fairly drastic predicate that is normally only used when some error
condition has occurred and there is no way of carrying on, or when
debugging.

   Often used via the debugging option 'a' or the '^C' interrupt option
'a'.

   'abort/0' is implemented by raising a reserved exception, which has
handler at the top level; *note ref-ere-int::.

Tips
----

Does not close any files that you may have opened.  When using 'see/1'
and 'tell/1', (rather than 'open/3', 'set_input/1', and 'set_output/1'),
close files yourself to avoid strange behavior after your program is
aborted and restarted.

Exceptions
----------

Does not throw errors, but is implemented by throwing a reserved
exception.

See Also
--------

'halt/[0,1]', 'break/0', 'runtime_entry/1', *note ref-ere-int::.


File: sicstus.info,  Node: mpg-ref-absolute_file_name,  Next: mpg-ref-acyclic_term,  Prev: mpg-ref-abort,  Up: mpg-bpr

11.3.3 'absolute_file_name/[2,3]'   hookable
--------------------------------------------

Synopsis
--------

'absolute_file_name'(+RELFILESPEC, -ABSFILENAME)

   'absolute_file_name'(+RELFILESPEC, -ABSFILENAME, +OPTIONS)

   Unifies ABSFILENAME with the absolute filename that corresponds to
the relative file specification RELFILESPEC.

Arguments
---------

RELFILESPEC
     "file_spec", must be ground

     A valid file specification.  See below for details.

ABSFILENAME
     "atom"

     Corresponding absolute filename.

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following.  The default is the empty
     list:

     'extensions(EXT)'
          Has no effect if FILESPEC contains a file extension.  EXT is
          an atom or a list of atoms, each atom representing an
          extension (e.g. ''.pl'') that should be tried when
          constructing the absolute file name.  The extensions are tried
          in the order they appear in the list.  Default value is EXT =
          ["], i.e. only the given FILESPEC is tried, no extension is
          added.  To specify 'extensions('')' or 'extensions([])' is
          equal to not giving any extensions option at all.

          When case-normalization is applied to the FILESPEC, e.g. on
          Windows, each atom in EXT will also be case-normalized before
          use.  That is, on Windows, specifying 'extensions(['.pl'])'
          will typically give the same result as 'extensions(['.PL'])'.
          Prior to release 4.3 the 'extensions/1' option was always case
          sensitive, also on Windows.

     'file_type(TYPE)'
          Picks an adequate extension for the operating system currently
          running, which means that programs using this option instead
          of 'extensions(Ext)' will be more portable between operating
          systems.  This extension mechanism has no effect if FILESPEC
          contains a file extension.  TYPE must be one of the following
          atoms:

          'text'
          'file'
               implies 'extensions([''])'.  FILESPEC is a file without
               any extension.  (Default)

          'source'
               implies 'extensions(['.pro','.pl',''])'.  FILESPEC is a
               Prolog source file, maybe with a '.pro' or '.pl'
               extension.

          'object'
               implies 'extensions(['.po'])'.  FILESPEC is a Prolog
               object file.

          'saved_state'
               implies 'extensions(['.sav',''])'.  FILESPEC is a
               saved-state, maybe with a '.sav' extension.

          'foreign_resource'
               FILESPEC is a foreign language shared object file, maybe
               with a system dependent extension.

          'executable   since release 4.0.2'
               FILESPEC is an executable file, maybe with a system
               dependent extension.

          'directory'
               implies 'extensions([''])'.  This option has two effects.
               First, for an access option other than 'access(none)' the
               file must exist and be a directory.  Second, the returned
               file name will end in slash ('/').

               Only when this option is present can
               'absolute_file_name/3' return the name of an existing
               directory with an access option other than 'access(none)'
               without raising an exception.

     'glob(GLOB)'
          Match file names against a pattern.  RELFILESPEC will be
          expanded to a directory and ABSFILENAME will be the absolute
          path to each child that matches both the GLOB pattern and any
          other filtering option, like 'access/1', 'extensions/1',
          'file_type/1', ....  The special children '.' and '..' will
          never be returned.

          The GLOB should be an atom specifying a "glob pattern"
          consisting of characters interpreted as follows:

             * A '*' matches any sequence of zero or more characters.

             * A '?' matches exactly one character.

             * A '{', '}', '[', ']' currently matches themself but are
               reserved for future expansion of the allowable patterns.

             * Any other character matches itself.

          With the options 'solutions(all)' and 'file_errors(fail)' this
          can be used to enumerate the contents of a directory.

     'access(MODE)'
          MODE must be an atom or a list of atoms.  If a list is given,
          then ABSFILENAME must obey every specified option in the list.
          This makes it possible to combine a read and write, or write
          and exist check, into one call.  If ABSFILENAME specifies a
          directory and an access option other than 'access(none)' is
          specified, then a permission error is signaled unless
          'file_type(directory)' is also specified.

          Each atom must be one of the following:

          'read'
               ABSFILENAME must be readable and exist.

          'write'
          'append'
               If ABSFILENAME exists, then it must be writable.  If it
               doesn't exist, then it must be possible to create.

          'exist'
               The file represented by ABSFILENAME must exist.

          'execute'
          'executable'
               The file represented by ABSFILENAME must be executable
               and exist.  This is ignored if 'file_type(directory)' is
               also specified.

          'search'
          'searchable'
               The directory represented by ABSFILENAME must be
               searchable and exist.  This is ignored unless
               'file_type(directory)' is also specified.

          'none'
               The file system is not accessed to determine existence or
               access properties of ABSFILENAME.  The first absolute
               file name that is derived from FILESPEC is returned.
               Note that if this option is specified, then no existence
               exceptions can be raised.  (Default)

          *Please note:* Most current file systems have complex access
          control mechanisms, such as access control lists (ACLs).
          These mechanisms makes it hard to determine the effective
          access permissions, short of actually attempting the file
          operations in question.  With networked file systems it may in
          fact be impossible to determine the effective access rights.

          Therefore, a simplified access control model is used by
          'absolute_file_name/3' and elsewhere in SICStus.

          On UNIX systems only the "classical" access control
          information is used, i.e. the read/write/execute "bits" for
          owner/group/other.

          Under Windows only the "FAT" access control information is
          used, i.e. a file may be marked as read-only.  A file is
          deemed executable if its extension is one of '.cmd', '.bat' or
          if it is classified as an executable by the Win32 API
          'GetBinaryType'.

          This may change to more faithfully reflect the effective
          permissions in a future release.

     'file_errors(VAL)'
     'fileerrors(VAL)'
          VAL is one of the following, where the default is determined
          by the current value of the 'fileerrors' Prolog flag:

          'error'
               Raise an exception if a file derived from FILESPEC has
               the wrong permissions, that is, can't be accessed at all,
               or doesn't satisfy the access modes specified with the
               'access' option.  This is the default if the Prolog flag
               'fileerrors' is set to its default value, 'on'.

          'fail'
               Fail if a file derived from FILESPEC has the wrong
               permissions.  Normally an exception is raised, which
               might not always be a desirable behavior, since files
               that do obey the access options might be found later on
               in the search.  When this option is given, the search
               space is guaranteed to be exhausted.  This is the default
               if the Prolog flag 'fileerrors' is set to 'off'.

     'solutions(VAL)'
          VAL is one of the following:

          'first'
               As soon as a file derived from FILESPEC is found, commit
               to that file.  Makes 'absolute_file_name/3' determinate.
               (Default)

          'all'
               Return each file derived from FILESPEC that is found.
               The files are returned through backtracking.  This option
               is probably most useful in combination with the option
               'file_errors(fail)'.

     'relative_to(FILEORDIRECTORY)'
          FILEORDIRECTORY should be an atom, and controls how to resolve
          relative filenames.  If it is '''', then file names will be
          treated as relative to the current working directory.  If a
          regular, existing file is given, then file names will be
          treated as relative to the directory containing
          FILEORDIRECTORY.  Otherwise, file names will be treated as
          relative to FILEORDIRECTORY.

          If 'absolute_file_name/3' is called from a goal in a file
          being loaded, then the default is the directory containing
          that file, accessible from the load context
          ('prolog_load_context/2').  Otherwise, the default is the
          current working directory.

          You can use 'file_systems:current_directory/1' to obtain the
          current working directory from a goal in a file being loaded.

     'if_user(VAL)   since release 4.3'
          controls how to resolve the special file name 'user'.  VAL is
          one of the following:

          'file'
               Treat the name 'user' like any other name, e.g. like
               'open/3' does.  This is the default.

          'user'
               Unifies ABSFILENAME with the atom 'user' and ignores the
               other options.  This corresponds to the behavior prior to
               SICStus Prolog 4.3.

          'error'
               Treat the name 'user' as a non-existing file, subject to
               the 'file_errors/1' option.

Description
-----------

If FILESPEC is 'user', and the option 'if_user(file)' is not in effect,
then special processing takes place, see the description of the
'if_user/1' option, above.  Otherwise (the default), unifies ABSFILENAME
with the first absolute file name that corresponds to the relative file
specification FILESPEC and that satisfies the access modes given by
OPTIONS.

   The functionality of 'absolute_file_name/3' is most easily described
as multi-phase process, in which each phase gets an infile from the
preceding phase, and constructs one or more outfiles to be consumed by
the succeeding phases.  The phases are:

  1. Syntactic rewriting

  2. Pattern expansion

  3. Extension expansion

  4. Access checking

   The first phase and each of the expansion phases modifies the infile
and produces variants that will be fed into the succeeding phases.  The
functionality of all phases but the first are decided with the option
list.  The last phase checks if the generated file exists, and if not
asks for a new variant from the preceding phases.  If the file exists,
but doesn't obey the access mode option, then a permission exception is
raised.  If the file obeys the access mode option, then
'absolute_file_name/3' commits to that solution, subject to the
'solutions' option, and unifies ABSFILENAME with the file name.  For a
thorough description, see below.

   Note that the relative file specification FILESPEC may also be of the
form PATH(FILESPEC), in which case the absolute file name of the file
FILESPEC in one of the directories designated by PATH is returned (see
the description of each phase below).

Syntactic rewriting
     This phase translates the relative file specification given by
     FILESPEC into the corresponding absolute file name.  The rewrite is
     done wrt. the value of the 'relative_to' option.  There can be more
     than one solution, in which case the outfile becomes the solutions
     in the order they are generated.  If the following phases fails,
     and there are no more solutions, then an existence exception is
     raised.

     FILESPEC can be a file search path, e.g.  'library('lists.pl')'.
     It can also refer to system properties, environment variables and
     the home directory of users.  *Note ref-fdi-syn::, for a
     description of syntactic rewriting.

Pattern expansion
     If the 'glob/1' option was specified all matching children of the
     directory will be enumerated.  See the 'glob' option.

Extension expansion
     See the 'extensions' and 'file_type' options.

Access checking
     See the 'access' option.

Final stage
     As a final stage, if 'file_type(directory)' is specified, then the
     file is suffixed with slash.  Otherwise, trailing slash will be
     removed except for root directories, such as '/' under UNIX or
     'c:/' under Windows.

Backtracking
------------

Can find multiple solutions only if the 'solutions(all)' option is used.

Exceptions
----------

'instantiation_error'
     Any of the OPTIONS arguments or RELFILESPEC is not ground.

'type_error'
     In OPTIONS or in RELFILESPEC.

'domain_error'
     OPTIONS contains an undefined option.

'existence_error'

     RELFILESPEC is syntactically valid but does not correspond to any
     file and an access option other than 'access(none)' was given.

'permission_error'
     RELFILESPEC names an existing file but the file does not obey the
     given access mode.

Comments
--------

If an option is specified more than once, then the rightmost option
takes precedence.  This provides for a convenient way of adding default
values by putting these defaults at the front of the list of options.
If 'absolute_file_name/3' succeeds, and the file access option was one
of {'read', 'write', 'append'}, then it is guaranteed(1) that the file
can be opened with 'open/[3,4]'.  If the access option was 'exist', then
the file does exist, but might be both read and write protected.

   If 'file_type(directory)' is not given, then the file access option
is other than 'none', and a specified file refers to a directory, then
'absolute_file_name/3' signals a permission error.

   'absolute_file_name/[2,3]' is sensitive to the 'fileerrors' Prolog
flag, which determines whether the predicate should fail or raise
permission errors when encountering files with the wrong permission.
Failing has the effect that the search space always is exhausted.

   If RELFILESPEC contains '..' components, then these are resolved by
removing directory components from the pathname, not by acessing the
file system.  This can give unexpected results, e.g. when soft links or
mount points are involved.

   This predicate is used for resolving file specification by built-in
predicates that open files.

Examples
--------

To check whether the file 'my_text' exists in the home directory, with
one of the extensions '.text' or '.txt', and is both writable and
readable:

     | ?- absolute_file_name('~/my_text', File,
                             [extensions(['.text','.txt']),
                             access([read,write])]).

   To check whether the directory 'bin' exists in the home directory:

     | ?- absolute_file_name('~/bin', Dir,
                             [file_type(directory),
                             access(exist)]).

   Here DIR would get a slash terminated value, such as '/home/joe/'.

   To list all files in the current directory:

     | ?- findall(File, absolute_file_name('.', File,
                             [glob('*'),
                             solutions(all), file_errors(fail)]), Files).

   To list all directories in the parent of the current directory
containing the string "sicstus":

     | ?- findall(File, absolute_file_name('..', File,
                             [glob('*sicstus*'),file_type(directory),
                             solutions(all), file_errors(fail)]), Files).

   To find a file 'cmd.exe' in any of the "usual places" where
executables are found, i.e.  by looking through the 'PATH' environment
variable:

     | ?- absolute_file_name(path('cmd.exe'), File,
                             [access(exist)]).


   This uses the predefined file search path 'path/1', *note ref-fdi::.

See Also
--------

'file_search_path/2', 'prolog_load_context/2', *note ref-fdi::, *note
ref-lps-flg::.

   ---------- Footnotes ----------

   (1) To the extent that the access permissions can be precisely
determined.  See the 'access/1' option above.


File: sicstus.info,  Node: mpg-ref-acyclic_term,  Next: mpg-ref-add_breakpoint,  Prev: mpg-ref-absolute_file_name,  Up: mpg-bpr

11.3.4 'acyclic_term/1'   ISO
-----------------------------

Synopsis
--------

'acyclic_term(+TERM)'   since release 4.3

   TERM is currently instantiated to a finite (acyclic) term.

Arguments
---------

TERM
     "term"

Description
-----------

True if X is finite (acyclic).  Runs in linear time.

Examples
--------

     | ?- X = g(Y), acyclic_term(f(X,X)).
     X = g(Y) ?
     yes
     | ?- X = g(X), acyclic_term(X).

     no
     | ?- X = g(X), acyclic_term(f(X)).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-act::.


File: sicstus.info,  Node: mpg-ref-add_breakpoint,  Next: mpg-ref-and,  Prev: mpg-ref-acyclic_term,  Up: mpg-bpr

11.3.5 'add_breakpoint/2'   development
---------------------------------------

Synopsis
--------

'add_breakpoint(+CONDITIONS, -BID)'

   Creates a breakpoint with CONDITIONS and with identifier BID.

Arguments
---------

:CONDITIONS
     "term".

     Breakpoint conditions.

BID
     "integer"

     Breakpoint identifier.

Exceptions
----------

'instantiation_error'
     CONDITIONS not instantiated enough.

'type_error'
     CONDITIONS not a proper list of callable term.

'domain_error'
     CONDITIONS not a proper list of valid breakpoint conditions

'context_error'
     Attempt to put a breakpoint on 'true/0' or 'fail/0'.

See Also
--------

*note Creating Breakpoints::, *note Breakpoint Predicates::.


File: sicstus.info,  Node: mpg-ref-and,  Next: mpg-ref-append,  Prev: mpg-ref-add_breakpoint,  Up: mpg-bpr

11.3.6 ',/2'   ISO
------------------

Synopsis
--------

+P ',' +Q

Arguments
---------

:P
     "callable", must be nonvar
:Q
     "callable", must be nonvar

Description
-----------

This is not normally regarded as a built-in predicate, since it is part
of the syntax of the language.  However, it is like a built-in predicate
in that you can say 'call((P , Q))' to execute P and then Q.

Backtracking
------------

Depends on P and Q.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-append,  Next: mpg-ref-arg,  Prev: mpg-ref-and,  Up: mpg-bpr

11.3.7 'append/3'
-----------------

Synopsis
--------

'append(?LIST1, ?LIST2, ?LIST3)'

Arguments
---------

LIST1
     "list of term"
LIST2
     "list of term"
LIST3
     "list of term"

     A list consisting of LIST1 followed by LIST2.

Description
-----------

Appends lists LIST1 and LIST2 to form LIST3:

     | ?- append([a,b], [a,d], X).

     X = [a,b,a,d]

     | ?- append([a], [a], [a]).

     no
     | ?- append(2, [a], X).

     no

   Takes LIST3 apart:
     | ?- append(X, [e], [b,e,e]).

     X = [b,e]

     | ?- append([b|X], [e,r], [b,o,r,e,r]).

     X = [o,r]

     | ?- append(X, Y, [h,i]).

     X = [],
     Y = [h,i] ;

     X = [h],
     Y = [i] ;

     X = [h,i],
     Y = [] ;

     no

Backtracking
------------

Suppose L is bound to a proper list.  That is, it has the form
[T1,...,TN] for some N.  In that instance, the following things apply:

  1. 'append(L, X, Y)' has at most one solution, whatever X and Y are,
     and cannot backtrack at all.
  2. 'append(X, Y, L)' has at most N+1 solutions, whatever X and Y are,
     and though it can backtrack over these it cannot run away without
     finding a solution.
  3. 'append(X, L, Y)', however, can backtrack indefinitely if X and Y
     are variables.

Examples
--------

The following examples are perfectly ordinary uses of 'append/3':

   To enumerate adjacent pairs of elements from a list:
     next_to(X, Y, (*in*) List3) :-
             append(_, [X,Y|_], List3).

   To check whether Word1 and Word2 are the same except for a single
transposition.  ('append/5' in 'library(lists)' would be better for this
task.)
     one_transposition(Word1, Word2) :-
             append(Prefix, [X,Y|Suffix], Word1),
             append(Prefix, [Y,X|Suffix], Word2).

     | ?- one_transposition("fred", X).
     X = "rfed" ;
     X = "ferd" ;
     X = "frde" ;
     no

   Given a list of words and commas, to backtrack through the phrases
delimited by commas:
     comma_phrase(List3, Phrase) :-
             append(F, [','|Rest], List3),
             !,
             (   Phrase = F
             ;   comma_phrase(Rest, Phrase)
             ).
     comma_phrase(List3, List3).

     | ?- comma_phrase([this,is,',',um,',',an, example], X).
     X = [this,is] ;
     X = [um] ;
     X = [an,example] ;
     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-acl::, 'library(lists)'.


File: sicstus.info,  Node: mpg-ref-arg,  Next: mpg-ref-ask_query,  Prev: mpg-ref-append,  Up: mpg-bpr

11.3.8 'arg/3'   ISO
--------------------

Synopsis
--------

'arg(+ARGNUM, +TERM, -ARG)'

   unifies ARG with the ARGNUMth argument of term TERM.

Arguments
---------

ARGNUM
     "integer", must be nonvar and non-negative.

TERM
     "compound", must be nonvar

ARG
     "term"

Description
-----------

The arguments are numbered from 1 upwards.

Exceptions
----------

'instantiation_error'
     if ARGNUM or TERM is unbound.

'type_error'
     if ARGNUM is not an integer, or TERM is not compound.

'domain_error'
     if ARGNUM is an integer less than zero.

Examples
--------

     | ?- arg(2, foo(a,b,c), X).

     X = b

See Also
--------

'functor/3', '=../2', *note ref-lte-act::.


File: sicstus.info,  Node: mpg-ref-ask_query,  Next: mpg-ref-assert,  Prev: mpg-ref-arg,  Up: mpg-bpr

11.3.9 'ask_query/4'   hookable
-------------------------------

Synopsis
--------

'ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)'

   Prints the question QUERY, then reads and processes user input
according to QUERYCLASS, and returns the result of the processing, the
abstract answer term ANSWER.  The HELP message may be printed in case of
invalid input.

Arguments
---------

QUERYCLASS
     "term", must be nonvar

     Determines the allowed values for the atom ANSWER.

QUERY
     "term"

     A message term.

HELP
     "term"

     A message term.

ANSWER
     "term"

     See QUERYCLASS

Description
-----------

All queries made by the system are handled by calling this predicate.

   First 'ask_query/4' calls 'query_hook/6' with the same arguments plus
the QUERY and HELP arguments converted to format-command lines.  If this
call succeeds, then it overrides all further processing done by
'ask_query/4'.  Otherwise, the query is processed in the following way:

   * Preparation phase: The parameters of the query processing, defined
     by QUERYCLASS (PROMPT, INPUTMETHOD, MAPMETHOD and FAILUREMODE) are
     retrieved using the four step procedure described above.  That is,
     the following alternatives are tried:
        - 'user:query_class_hook/5';
        - ''SU_messages':query_class/5';
        - the built-in copy of 'query_class/5'.

   * Input phase: The user is prompted with PROMPT, input is read
     according to INPUTMETHOD, and the result is returned in RAWINPUT.

     The four step procedure is used for performing this phase, the
     predicates tried are the following:
        - 'user:query_input_hook/3';
        - ''SU_messages':query_input/3';
        - the built-in copy of 'query_input/3'.

   * Mapping phase: The RAWINPUT returned by the input phase is mapped
     to the ANSWER of the query.  This mapping is defined by the
     MAPMETHOD parameter, and the result of the conversion is returned
     in RESULT, which can be:
        - 'success'--the mapping was successful, ANSWER is valid;

        - 'failure'--the mapping was unsuccessful, the query has to be
          repeated;

        - 'failure(WARNING)'--same as 'failure', but first the given
          warning message has to be printed.

     The four step procedure is used for performing this phase, the
     predicates tried are the following:
        - 'user:query_map_hook/4';
        - ''SU_messages':query_map/4';
        - the built-in copy of 'query_map/4'.

     If the mapping phase succeeds, then 'ask_query/4' returns with the
     ANSWER delivered by this phase.

   * If the mapping does not succeed, then the query has to be repeated.
     If the RESULT returned by the mapping contains a warning message,
     then it is printed using 'print_message/2'.  FAILUREMODE specifies
     whether to print the help message and whether to re-print the query
     text.  Subsequently, the input and mapping phases are called again,
     and this is repeated until the mapping is successful.

Exceptions
----------

'instantiation_error'
     QUERYCLASS, QUERY, or HELP uninstantiated.

'type_error'
     QUERYCLASS not an atom.

'domain_error'
     QUERYCLASS not a valid query class.

See Also
--------

*note Query Processing::.


File: sicstus.info,  Node: mpg-ref-assert,  Next: mpg-ref-asserta,  Prev: mpg-ref-ask_query,  Up: mpg-bpr

11.3.10 'assert/[1,2]'
----------------------

Synopsis
--------

These predicates add a dynamic clause, CLAUSE, to the Prolog database.
They optionally return a database reference in REF:

   'assert(+CLAUSE)'

   'assert(+CLAUSE, -REF)'

   It is undefined whether CLAUSE will precede or follow the clauses
already in the database.

Arguments
---------

:CLAUSE
     "callable", must be nonvar

     A valid dynamic Prolog clause.

REF
     "db_reference", must be var

     A database reference, which uniquely identifies the newly asserted
     CLAUSE.

Description
-----------

CLAUSE must be of the form:
            HEAD
     or     HEAD :- BODY
     or     M:CLAUSE

   where HEAD is of type callable and BODY is a valid clause body.  If
specified, then M must be an atom.

   'assert(HEAD)' means assert the unit-clause HEAD.  The exact same
effect can be achieved by 'assert((HEAD :- true))'.

   If BODY is uninstantiated, then it is taken to mean 'call(BODY)'.
For example, (A) is equivalent to (B):
     | ?- assert((p(X) :- X)).             (A)
     | ?- assert((p(X) :- call(X))).       (B)

   REF should be uninstantiated; a range exception is signalled if REF
does not unify with its return value.  This exception is signalled after
the assert has been completed.

   The procedure for CLAUSE must be dynamic or undefined.  If it is
undefined, then it is set to be dynamic.

   When an assert takes place, the new clause is immediately seen by any
subsequent call to the procedure.  However, if there is a currently
active call of the procedure at the time the clause is asserted, then
the new clause is not encountered on backtracking by that call.  See
*note ref-mdb-bas:: for further explanation of what happens when
currently running code is modified.

   Any uninstantiated variables in the TERM will be replaced by brand
new, unattributed variables (*note ref-sem-sec::).

Exceptions
----------

'instantiation_error'
     HEAD (in CLAUSE) or M is uninstantiated.

'type_error'
     HEAD is not a callable, or M is not an atom, or BODY is not a valid
     clause body.

'permission_error'
     the procedure corresponding to HEAD is not dynamic

'uninstantiation_error'
     REF is not a variable

See Also
--------

*note ref-mdb-acd::.


File: sicstus.info,  Node: mpg-ref-asserta,  Next: mpg-ref-assertz,  Prev: mpg-ref-assert,  Up: mpg-bpr

11.3.11 'asserta/[1,2]'   ISO
-----------------------------

Synopsis
--------

These predicates add a dynamic clause, CLAUSE, to the Prolog database.
They optionally return a database reference in REF:

   'asserta(+CLAUSE)'

   'asserta(+CLAUSE, -REF)'

   CLAUSE will precede all existing clauses in the database.

Arguments
---------

:CLAUSE
     "callable", must be nonvar

     A valid dynamic Prolog clause.

REF
     "db_reference", must be var

     A database reference, which uniquely identifies the newly asserted
     CLAUSE.

Description
-----------

CLAUSE must be of the form:
            HEAD
     or     HEAD :- BODY
     or     M:CLAUSE

   where HEAD is of type callable and BODY is a valid clause body.  If
specified, then M must be an atom.

   'asserta(HEAD)' means assert the unit-clause HEAD.  The exact same
effect can be achieved by 'asserta((HEAD :- true))'.

   If BODY is uninstantiated, then it is taken to mean 'call(BODY)'.
For example, (A) is equivalent to (B):
     | ?- asserta((p(X) :- X)).             (A)
     | ?- asserta((p(X) :- call(X))).       (B)

   REF should be uninstantiated; a range exception is signalled if REF
does not unify with its return value.  This exception is signalled after
the assert has been completed.

   The procedure for CLAUSE must be dynamic or undefined.  If it is
undefined, then it is set to be dynamic.

   When an assert takes place, the new clause is immediately seen by any
subsequent call to the procedure.  However, if there is a currently
active call of the procedure at the time the clause is asserted, then
the new clause is not encountered on backtracking by that call.  See
*note ref-mdb-bas:: for further explanation of what happens when
currently running code is modified.

   Any uninstantiated variables in the TERM will be replaced by brand
new, unattributed variables (*note ref-sem-sec::).

Exceptions
----------

'instantiation_error'
     HEAD (in CLAUSE) or M is uninstantiated.

'type_error'
     HEAD is not a callable, or M is not an atom, or BODY is not a valid
     clause body.

'permission_error'
     the procedure corresponding to HEAD is not dynamic

'uninstantiation_error'
     REF is not a variable

See Also
--------

*note ref-mdb-acd::.


File: sicstus.info,  Node: mpg-ref-assertz,  Next: mpg-ref-at_end_of_line,  Prev: mpg-ref-asserta,  Up: mpg-bpr

11.3.12 'assertz/[1,2]'   ISO
-----------------------------

Synopsis
--------

These predicates add a dynamic clause, CLAUSE, to the Prolog database.
They optionally return a database reference in REF:

   'assertz(+CLAUSE)'

   'assertz(+CLAUSE, -REF)'

   CLAUSE will follow all existing clauses in the database.

Arguments
---------

:CLAUSE
     "callable", must be nonvar

     A valid dynamic Prolog clause.

REF
     "db_reference", must be var

     A database reference, which uniquely identifies the newly asserted
     CLAUSE.

Description
-----------

CLAUSE must be of the form:
            HEAD
     or     HEAD :- BODY
     or     M:CLAUSE

   where HEAD is of type callable and BODY is a valid clause body.  If
specified, then M must be an atom.

   'assertz(HEAD)' means assert the unit-clause HEAD.  The exact same
effect can be achieved by 'assertz((HEAD :- true))'.

   If BODY is uninstantiated, then it is taken to mean 'call(BODY)'.
For example, (A) is equivalent to (B):
     | ?- assertz((p(X) :- X)).             (A)
     | ?- assertz((p(X) :- call(X))).       (B)

   REF should be uninstantiated; a range exception is signalled if REF
does not unify with its return value.  This exception is signalled after
the assert has been completed.

   The procedure for CLAUSE must be dynamic or undefined.  If it is
undefined, then it is set to be dynamic.

   When an assert takes place, the new clause is immediately seen by any
subsequent call to the procedure.  However, if there is a currently
active call of the procedure at the time the clause is asserted, then
the new clause is not encountered on backtracking by that call.  See
*note ref-mdb-bas:: for further explanation of what happens when
currently running code is modified.

   Any uninstantiated variables in the TERM will be replaced by brand
new, unattributed variables (*note ref-sem-sec::).

Exceptions
----------

'instantiation_error'
     HEAD (in CLAUSE) or M is uninstantiated.

'type_error'
     HEAD is not a callable, or M is not an atom, or BODY is not a valid
     clause body.

'permission_error'
     the procedure corresponding to HEAD is not dynamic

'uninstantiation_error'
     REF is not a variable

Examples
--------

     | ?- assertz(mammal(kangaroo)).
     yes
     | ?- assertz(mammal(whale), Ref).
     Ref = '$ref'(1258504,210) ? <RET>
     yes
     | ?- listing(mammal).
     mammal(kangaroo).
     mammal(whale).
     yes

See Also
--------

*note ref-mdb-acd::.


File: sicstus.info,  Node: mpg-ref-at_end_of_line,  Next: mpg-ref-at_end_of_stream,  Prev: mpg-ref-assertz,  Up: mpg-bpr

11.3.13 'at_end_of_line/[0,1]'
------------------------------

Synopsis
--------

'at_end_of_line'

   'at_end_of_line(+STREAM)'

   Test whether end of line (record) has been reached for the current
input stream or for the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog input stream, defaults to the current input stream.

Description
-----------

Succeeds when end of line (record) is reached for the specified input
stream.  An input stream reaches end of line when all the characters
except <LFD> of the current line have been read.

   Is also true whenever 'at_end_of_stream/[0,1]' is true.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

'at_end_of_stream/[0,1]', 'skip_line/[0,1]', 'set_input/1'.


File: sicstus.info,  Node: mpg-ref-at_end_of_stream,  Next: mpg-ref-atom,  Prev: mpg-ref-at_end_of_line,  Up: mpg-bpr

11.3.14 'at_end_of_stream/[0,1]'   ISO
--------------------------------------

Synopsis
--------

'at_end_of_stream'

   'at_end_of_stream(+STREAM)'

   Tests whether the end has been reached for the current input stream
or for the input stream STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog input stream, defaults to the current input stream.

Description
-----------

Checks if the end has been reached for the specified input stream.  An
input stream reaches the end when all items (characters or bytes) except
'EOF' (-1) of the stream have been read.  It remains at the end after
'EOF' has been read.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Comments
--------

'at_end_of_stream/[0,1]' peeks ahead for next input item if there is no
item available on the buffer of the specified input stream.

   Note that 'at_end_of_stream/[0,1]' never blocks.  If reading ahead
would block, then 'at_end_of_stream/[0,1]' will fail, even if the stream
is actually at its end.  If you want to ensure that end-of-stream
condition is always properly detected, even if that entails blocking
until further input is possible, then you can use 'peek_code/[1,2]' or
'peek_byte/[1,2]'.

     *Please note*: The design of 'at_end_of_stream/[0,1]' makes it
     inherently unreliable.  It is present only for ISO standards
     compliance.  It is better to read or peek until one of the end of
     file indications is returned.

See Also
--------

'at_end_of_line/[0,1]'.


File: sicstus.info,  Node: mpg-ref-atom,  Next: mpg-ref-atom_chars,  Prev: mpg-ref-at_end_of_stream,  Up: mpg-bpr

11.3.15 'atom/1'   ISO
----------------------

Synopsis
--------

'atom(+TERM)'

   Succeeds if TERM is currently instantiated to an atom.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- atom(pastor).

     yes
     | ?- atom(Term).

     no
     | ?- atom(1).

     no
     | ?- atom('Time').

     yes

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-atom_chars,  Next: mpg-ref-atom_codes,  Prev: mpg-ref-atom,  Up: mpg-bpr

11.3.16 'atom_chars/2'   ISO
----------------------------

Synopsis
--------

'atom_chars(+ATOM, -CHARS)'

   'atom_chars(-ATOM, +CHARS)'

   CHARS is the "chars" comprising the printed representation of ATOM.

Arguments
---------

CHARS
     "chars"

     The "chars" comprising the printed representation of ATOM.

ATOM
     "atom"

     The atom containing exactly those characters, even if the
     characters look like the printed representation of a number.

Description
-----------

Initially, either ATOM must be instantiated to an atom, or CHARS must be
instantiated to a proper "chars".

   Any atom that can be read or written by Prolog can be constructed or
decomposed by 'atom_chars/2'.

Exceptions
----------

'instantiation_error'
     ATOM is uninstantiated and CHARS is not instantiated enough.

'type_error'
     ATOM is not an atom or CHARS cannot be unified with a "chars".

'representation_error'
     CHARS is a list corresponding to an atom that can't be represented

   The check of CHARS when ATOM is instantiated was added in release 4.3
for alignment with the ISO Prolog standard.  Previous releases simply
failed in this case instead of reporting an error for malformed CHARS.

See Also
--------

'atom_codes/2'.


File: sicstus.info,  Node: mpg-ref-atom_codes,  Next: mpg-ref-atom_concat,  Prev: mpg-ref-atom_chars,  Up: mpg-bpr

11.3.17 'atom_codes/2'   ISO
----------------------------

Synopsis
--------

'atom_codes(+ATOM, -CODES)'

   'atom_codes(-ATOM, +CODES)'

   CODES is the "codes" comprising the printed representation of ATOM.

Arguments
---------

CODES
     "codes"

     The "codes" comprising the printed representation of ATOM.

ATOM
     "atom"

     The atom containing exactly those characters, even if the
     characters look like the printed representation of a number.

Description
-----------

Initially, either ATOM must be instantiated to an atom, or CODES must be
instantiated to a proper "codes".

   Any atom that can be read or written by Prolog can be constructed or
decomposed by 'atom_codes/2'.

Exceptions
----------

'instantiation_error'
     ATOM is uninstantiated and CODES is not instantiated enough

'type_error'
     ATOM is not an atom or CODES cannot be unified with a list of
     integers

'representation_error'
     An element of CODES is an invalid character code, or CODES is a
     list corresponding to an atom that can't be represented

   The check of CODES when ATOM is instantiated was added in release 4.3
for alignment with the ISO Prolog standard.  Previous releases simply
failed in this case instead of reporting an error for malformed CODES.

See Also
--------

'atom_chars/2'.


File: sicstus.info,  Node: mpg-ref-atom_concat,  Next: mpg-ref-atom_length,  Prev: mpg-ref-atom_codes,  Up: mpg-bpr

11.3.18 'atom_concat/3'   ISO
-----------------------------

Synopsis
--------

'atom_concat(+ATOM1,+ATOM2,-ATOM12)'

   'atom_concat(-ATOM1,-ATOM2,+ATOM12)'

   The characters of the atom ATOM1 concatenated with those of ATOM2 are
the same as the characters of atom ATOM12.

Arguments
---------

ATOM1
     "atom"

ATOM2
     "atom"

ATOM12
     "atom"

Description
-----------

Initially, either both ATOM1 and ATOM2, or ATOM12, must be instantiated
to atoms.  If only ATOM12 is instantiated, then nondeterminately
enumerates all possible atom-pairs that concatenate to the given atom,
e.g.:

     | ?- atom_concat(A, B, 'ab').

     A = '',
     B = ab ? ;

     A = a,
     B = b ? ;

     A = ab,
     B = ''  ;

     no

Exceptions
----------

'instantiation_error'
     More than one argument uninstantiated.

'type_error'
     An instantiated argument is not an atom.

'representation_error'
     ATOM12 is too long to be represented.

See Also
--------

'atom_length/2', 'sub_atom/5'.


File: sicstus.info,  Node: mpg-ref-atom_length,  Next: mpg-ref-atomic,  Prev: mpg-ref-atom_concat,  Up: mpg-bpr

11.3.19 'atom_length/2'   ISO
-----------------------------

Synopsis
--------

'atom_length(+ATOM, -LENGTH)'

   LENGTH is the number of characters of the atom ATOM.

Arguments
---------

ATOM
     "atom", must be nonvar

LENGTH
     "integer"

Exceptions
----------

'instantiation_error'
     ATOM is uninstantiated

'type_error'
     ATOM is not an atom, or LENGTH cannot be unified with an integer

'domain_error'
     LENGTH < 0

See Also
--------

'atom_length/2', 'atom_concat/3', 'sub_atom/5'.


File: sicstus.info,  Node: mpg-ref-atomic,  Next: mpg-ref-bagof,  Prev: mpg-ref-atom_length,  Up: mpg-bpr

11.3.20 'atomic/1'   ISO
------------------------

Synopsis
--------

'atomic(+TERM)'

   Succeeds if TERM is currently instantiated to an atom or a number.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- atomic(9).

     yes
     | ?- atomic(a).

     yes
     | ?- atomic("a").

     no
     | ?- assert(foo(1), Ref), atomic(Ref).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-bagof,  Next: mpg-ref-bb_delete,  Prev: mpg-ref-atomic,  Up: mpg-bpr

11.3.21 'bagof/3'   ISO
-----------------------

Synopsis
--------

'bagof(+TEMPLATE, +GENERATOR, -SET)'

   Like 'setof/3' except that the list (or alternative lists) returned
will not be ordered, and may contain duplicates.  This relaxation saves
time and space in execution.

Arguments
---------

TEMPLATE
     "term"

:GENERATOR
     "callable", must be nonvar

     A goal to be proved as if by 'call/1'.

SET
     "list of term", non-empty set

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

See 'findall/3' for examples that illustrate the differences among
'findall/3', 'setof/3', and 'bagof/3'.

See Also
--------

'findall/3', 'setof/3', '^/2', *note ref-all::.


File: sicstus.info,  Node: mpg-ref-bb_delete,  Next: mpg-ref-bb_get,  Prev: mpg-ref-bagof,  Up: mpg-bpr

11.3.22 'bb_delete/2'
---------------------

Synopsis
--------

'bb_delete(:KEY, -TERM)'

   If a term is currently stored under KEY, then the term is deleted,
and a copy of it is unified with TERM.  Otherwise, 'bb_delete/2'
silently fails.

Arguments
---------

:KEY
     "bbkey"

TERM
     "term"

Exceptions
----------

'instantiation_error'
     KEY is not instantiated

'type_error'
     KEY is not an atom or a small integer.

See Also
--------

*note ref-mdb-bbd::.


File: sicstus.info,  Node: mpg-ref-bb_get,  Next: mpg-ref-bb_put,  Prev: mpg-ref-bb_delete,  Up: mpg-bpr

11.3.23 'bb_get/2'
------------------

Synopsis
--------

'bb_get(:KEY, -TERM)'

   If a term is currently stored under KEY, then a copy of it is unified
with TERM.  Otherwise, 'bb_get/2' silently fails.

Arguments
---------

:KEY
     "bbkey"

TERM
     "term"

Exceptions
----------

'instantiation_error'
     KEY is not instantiated

'type_error'
     KEY is not an atom or a small integer.

See Also
--------

*note ref-mdb-bbd::.


File: sicstus.info,  Node: mpg-ref-bb_put,  Next: mpg-ref-bb_update,  Prev: mpg-ref-bb_get,  Up: mpg-bpr

11.3.24 'bb_put/2'
------------------

Synopsis
--------

'bb_put(:KEY, +TERM)'

   A copy of TERM is stored under KEY in the source module blackboard.
Any previous term stored under the same KEY is simply deleted.

Arguments
---------

:KEY
     "bbkey"

TERM
     "term"

Description
-----------

Any uninstantiated variables in the TERM will be replaced by brand new,
unattributed variables (*note ref-sem-sec::).

Exceptions
----------

'instantiation_error'
     KEY is not instantiated

'type_error'
     KEY is not an atom or a small integer.

See Also
--------

*note ref-mdb-bbd::.


File: sicstus.info,  Node: mpg-ref-bb_update,  Next: mpg-ref-block,  Prev: mpg-ref-bb_put,  Up: mpg-bpr

11.3.25 'bb_update/3'
---------------------

Synopsis
--------

'bb_update(:KEY, -OLDTERM, +NEWTERM)'

   If a term is currently stored under KEY and unifies with OLDTERM,
then the term is replaced by a copy of NEWTERM.  Otherwise,
'bb_update/3' silently fails.  This predicate provides an atomic swap
operation.

Arguments
---------

:KEY
     "bbkey"

OLDTERM
     "term"

NEWTERM
     "term"

Description
-----------

Any uninstantiated variables in the TERM will be replaced by brand new,
unattributed variables (*note ref-sem-sec::).

Exceptions
----------

'instantiation_error'
     KEY is not instantiated

'type_error'
     KEY is not an atom or a small integer.

See Also
--------

*note ref-mdb-bbd::.


File: sicstus.info,  Node: mpg-ref-block,  Next: mpg-ref-break,  Prev: mpg-ref-bb_update,  Up: mpg-bpr

11.3.26 'block/1'   declaration
-------------------------------

Synopsis
--------

':- block +BLOCKSPEC'

   Specifies conditions for blocking goals of the predicates referred to
by BLOCKSPEC.

Arguments
---------

:BLOCKSPEC
     "callable", must be ground

     Goal template or list of goal templates, of the form 'F(ARG1,
     ARG2,...)'.  Each ARGN is one of:

     '-'
          part of a block condition

     '?'
          otherwise

Description
-----------

When a goal for a block declared predicate is to be executed, the block
specs are interpreted as conditions for blocking the goal, and if at
least one condition evaluates to 'true', then the goal is blocked.

   A block condition evaluates to 'true' iff all arguments specified as
'-' are uninstantiated, in which case the goal is blocked until at least
one of those variables is instantiated.  If several conditions evaluate
to 'true', then the implementation picks one of them and blocks the goal
accordingly.

   The recommended style is to write the block declarations in front of
the source code of the predicate they refer to.  Indeed, they are part
of the source code of the predicate, and must precede the first clause.
For example, with the definition:

     :- block merge(-,?,-), merge(?,-,-).

     merge([], Y, Y).
     merge(X, [], X).
     merge([H|X], [E|Y], [H|Z]) :- H @< E,  merge(X, [E|Y], Z).
     merge([H|X], [E|Y], [E|Z]) :- H @>= E, merge([H|X], Y, Z).

calls to 'merge/3' having uninstantiated arguments in the first _and_
third position _or_ in the second _and_ third position will suspend.

   The behavior of blocking goals for a given predicate on
uninstantiated arguments cannot be switched off, except by abolishing or
redefining the predicate.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'instantiation_error'
     BLOCKSPEC not ground.

'type_error'
     BLOCKSPEC not a valid specification.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Block Declarations::.


File: sicstus.info,  Node: mpg-ref-break,  Next: mpg-ref-breakpoint_expansion,  Prev: mpg-ref-block,  Up: mpg-bpr

11.3.27 'break/0'   development
-------------------------------

Synopsis
--------

'break'

   causes the current execution to be interrupted; enters next break
level.

Description
-----------

The first time 'break/0' is called, it displays the message
     % Break level 1
     % 1
     | ?-

   The system is then ready to accept input as though it were at top
level.  If another call to 'break/0' is encountered, then it moves up to
level 2, and so on.  The break level is displayed on a separate line
before each top-level prompt.

   To close a break level and resume the execution that was suspended,
type '^D'.  'break/0' then succeeds, and execution of the interrupted
program is resumed.

   Changes can be made to a running program while in a break level.  Any
change made to a procedure will take effect the next time that procedure
is called.  See *note ref-mdb-rcd:: for details of what happens if a
procedure that is currently being executed is redefined.  When a break
level is entered, the debugger is turned off (although leashing and
spypoints are retained).  When a break level is exited, the debugging
state is restored to what it was before the break level was entered.

   Often used via the debugging option 'b'.

Exceptions
----------

Catches otherwise uncaught exceptions and issues an error message.

See Also
--------

'abort/0', 'halt/[0,1]', *note Nested::.


File: sicstus.info,  Node: mpg-ref-breakpoint_expansion,  Next: mpg-ref-byte_count,  Prev: mpg-ref-break,  Up: mpg-bpr

11.3.28 'breakpoint_expansion/2'   hook, development
----------------------------------------------------

Synopsis
--------

':- multifile user:breakpoint_expansion/2.'

   'user:breakpoint_expansion(+MACRO, -BODY)'

   Defines debugger condition macros.

Arguments
---------

MACRO
     "term"

     Breakpoint test or action.

BODY
     "term"

     Expanded breakpoint test or action, may be composite.

Exceptions
----------

Exceptions are treated as failures, except an error message is printed
as well.

See Also
--------

*note Breakpoint Conditions::.


File: sicstus.info,  Node: mpg-ref-byte_count,  Next: mpg-ref-call,  Prev: mpg-ref-breakpoint_expansion,  Up: mpg-bpr

11.3.29 'byte_count/2'
----------------------

Synopsis
--------

'byte_count(+STREAM, -COUNT)'

   Obtains the total number of bytes either input from or output to the
open binary stream STREAM and unifies it with COUNT.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open _binary_ stream.

COUNT
     "integer"

     The resulting byte count of the stream.

Description
-----------

A freshly opened stream has a byte count of 0.  When a byte is input
from or output to a Prolog stream, the byte count of the Prolog stream
is increased by one.

   The count is reset by 'set_stream_position/2'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

'byte_count/2', 'line_count/2', 'line_position/2', 'stream_position/2',
'set_stream_position/2', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-call,  Next: mpg-ref-call_cleanup,  Prev: mpg-ref-byte_count,  Up: mpg-bpr

11.3.30 'call/[1,2,...,255]'   ISO
----------------------------------

Synopsis
--------

'call(+P)'

   Proves (executes) P.

   'call(+P,?Q,...)'

   Executes the goal obtained by augmenting P by the remaining
arguments.

Arguments
---------

:P
     "callable", must be nonvar
Q
     term ...

Description
-----------

If P is instantiated to an atom or compound term, then the goal
'call(P)' is executed exactly as if that term appeared textually in its
place, except that any cut ('!') occurring in P only cuts alternatives
in the execution of P.  Only 'call/1..8' are required by ISO.

Backtracking
------------

Depends on P.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

'maplist/2' in 'library(lists)' is defined as:

     maplist(Pred, Xs) :-
             (   foreach(X,Xs),
                 param(Pred)
             do  call(Pred, X)
             ).

See Also
--------

*note ref-sem-cal::.


File: sicstus.info,  Node: mpg-ref-call_cleanup,  Next: mpg-ref-call_residue_vars,  Prev: mpg-ref-call,  Up: mpg-bpr

11.3.31 'call_cleanup/2'
------------------------

'call_cleanup(+GOAL, +CLEANUP)'

Synopsis
--------

Executes the procedure call GOAL.  When GOAL succeeds determinately, is
cut, fails, or raises an exception, CLEANUP is executed.

Arguments
---------

:GOAL
     "callable", must be nonvar

:CLEANUP
     "callable", must be nonvar

Description
-----------

This construction can be used to ensure that CLEANUP is executed as soon
as GOAL has completed execution, no matter how it finishes.  In more
detail:

   When 'call_cleanup/2' with a continuation C is called or backtracked
into, first GOAL is called or backtracked into.  Then there are four
possibilities:

  1. GOAL succeeds determinately, possibly leaving some blocked
     subgoals.  CLEANUP is executed with continuation C.

  2. GOAL succeeds with some alternatives outstanding.  Execution
     proceeds to C.  If a cut that removes the outstanding alternatives
     is encountered, then CLEANUP is executed with continuation to
     proceed after the cut.  Also, if an exception E that will be caught
     by an ancestor of the 'call_cleanup/2' GOAL is raised, then CLEANUP
     is executed with continuation 'raise_exception(E)'.

  3. GOAL fails.  CLEANUP is executed with continuation 'fail'.

  4. GOAL raises an exception E.  CLEANUP is executed with continuation
     'raise_exception(E)'.

   In a typical use of 'call_cleanup/2', CLEANUP succeeds determinately
after performing some side-effect; otherwise, unexpected behavior may
result.

   Note that the Prolog top-level operates as a read-execute-fail loop,
which backtracks into or cuts the query when the user types ';' or <RET>
respectively.  Also, some predicates, such as 'halt/[0,1]' and
'abort/0', are implemented in terms of exceptions.  All of these
circumstances can trigger the execution of CLEANUP.

Backtracking
------------

Depends on the arguments.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-call_residue_vars,  Next: mpg-ref-callable,  Prev: mpg-ref-call_cleanup,  Up: mpg-bpr

11.3.32 'call_residue_vars/2'
-----------------------------

'call_residue_vars(+GOAL, -VARS)'

Synopsis
--------

Executes the procedure call GOAL, unifying VARS with the list of
residual variables that have blocked goals or attributes attached to
them.

Arguments
---------

:GOAL
     "callable", must be nonvar

VARS
     "list of var"

Description
-----------

GOAL is executed as if by 'call/1'.  VARS is unified with the list of
new variables created during the call that remain unbound and have
blocked goals or attributes attached to them.  For example:

     | ?- call_residue_vars((dif(X,f(Y)), X=f(Z)), Vars).

     X = f(Z),
     Vars = [Z,Y],
     prolog:dif(f(Z),f(Y)) ?

Backtracking
------------

Depends on GOAL.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-callable,  Next: mpg-ref-catch,  Prev: mpg-ref-call_residue_vars,  Up: mpg-bpr

11.3.33 'callable/1'   ISO
--------------------------

Synopsis
--------

'callable(+TERM)'

   Succeeds if TERM is currently instantiated to an atom or a compound
term.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- callable(a).

     yes
     | ?- callable(a(1,2,3)).

     yes
     | ?- callable([1,2,3]).

     yes
     | ?- callable(1.1).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-catch,  Next: mpg-ref-char_code,  Prev: mpg-ref-callable,  Up: mpg-bpr

11.3.34 'catch/3'   ISO
-----------------------

Synopsis
--------

'catch(+PROTECTEDGOAL, -EXCEPTION, +HANDLER)'

   Specify an exception handler for PROTECTEDGOAL, and call
PROTECTEDGOAL, as described in *note ref-ere::.

Arguments
---------

:PROTECTEDGOAL
     "callable", must be nonvar

EXCEPTION
     "term"

:HANDLER
     "callable", must be nonvar

Examples
--------

Fail on exception:
     :- meta_predicate fail_on_exception(0).
     fail_on_exception(C):-
         catch(C, E, print_exception_then_fail(C, E)).

     print_exception_then_fail(C, E) :-
         format(user_error, 'Exception occured while calling ~q:~n', [C]),
         print_message(warning, E),
         fail.

Backtracking
------------

Depends on PROTECTEDGOAL and HANDLER.

Exceptions
----------

None.

See Also
--------

*note ref-ere::.


File: sicstus.info,  Node: mpg-ref-char_code,  Next: mpg-ref-char_conversion,  Prev: mpg-ref-catch,  Up: mpg-bpr

11.3.35 'char_code/2'   ISO
---------------------------

Synopsis
--------

'char_code(+CHAR, -CODE)'

   'char_code(-CHAR, +CODE)'

   CODE is the character code comprising the printed representation of
CHAR.

Arguments
---------

CHAR
     "char"

     The "char" whose code is CODE.

CODE
     "code"

     The "code" corresponding to CHAR.

Description
-----------

Initially, at least one argument must be instantiated.

Exceptions
----------

'instantiation_error'
     CHAR and CODE are both uninstantiated

'type_error'
     CHAR is not a "char" or CODE is not an integer.

'representation_error'
     CODE is not a "code".

See Also
--------

'atom_codes/2', 'number_codes/2'.


File: sicstus.info,  Node: mpg-ref-char_conversion,  Next: mpg-ref-character_count,  Prev: mpg-ref-char_code,  Up: mpg-bpr

11.3.36 'char_conversion/2'   ISO
---------------------------------

Synopsis
--------

'char_conversion(+INCHAR, +OUTCHAR)'

   The mapping of INCHAR to OUTCHAR is added to the character-conversion
mapping.

Arguments
---------

INCHAR
     "char", must be nonvar

OUTCHAR
     "char", must be nonvar

Description
-----------

The mapping of INCHAR to OUTCHAR is added to the character-conversion
mapping.  This means that in all subsequent term and program input
operations any _unquoted_ occurrence of INCHAR will be replaced by
OUTCHAR.  The rationale for providing this facility is that in some
extended character sets (such as Japanese JIS character sets) the same
character can appear several times and thus have several codes, which
the users normally expect to be equivalent.  It is advisable to always
quote the arguments of 'char_conversion/2'.

   Any previous mapping of INCHAR is replaced by the new one.

   *Please note*: the mapping is _global_, as opposed to being local to
the current module, Prolog text, or otherwise.

Exceptions
----------

'instantiation_error'
     An argument is uninstantiated

'type_error'
     An argument is not a "char"

See Also
--------

*note Glossary::.


File: sicstus.info,  Node: mpg-ref-character_count,  Next: mpg-ref-clause,  Prev: mpg-ref-char_conversion,  Up: mpg-bpr

11.3.37 'character_count/2'
---------------------------

Synopsis
--------

'character_count(+STREAM, -COUNT)'

   Obtains the total number of characters either input from or output to
the open text stream STREAM and unifies it with COUNT.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open _text_ stream

COUNT
     "integer"

     The resulting character count of the stream

Description
-----------

A freshly opened text stream has a character count of 0.  When a
character is input from or output to a non-interactive Prolog stream,
the character count of the Prolog stream is increased by one.  Character
count for an interactive stream reflects the total character input from
or output to any interactive stream, i.e. all interactive streams share
the same counter.

   A 'nl/[0,1]' operation also increases the character count of a stream
by one.

   The count is reset by 'set_stream_position/2'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

'byte_count/2', 'line_count/2', 'line_position/2', 'stream_position/2',
'set_stream_position/2', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-clause,  Next: mpg-ref-close,  Prev: mpg-ref-character_count,  Up: mpg-bpr

11.3.38 'clause/[2,3]'   ISO
----------------------------

Synopsis
--------

'clause(+HEAD, -BODY)'

   'clause(+HEAD, -BODY, -REF)'

   'clause(-HEAD, -BODY, +REF)'

   Searches the database for a clause whose head matches HEAD and whose
body matches BODY.

Arguments
---------

:HEAD
     "callable"

     A term whose functor names a dynamic procedure.

BODY
     "callable"

REF
     "db_reference"

Description
-----------

Initially, at least one of HEAD and REF must be instantiated.

   In the case of unit-clauses, BODY is unified with 'true'.

   If a procedure consists entirely of unit-clauses, then there is no
point in calling 'clause/2' on it.  It is simpler and faster to call the
procedure.

   In 'clause/3', either HEAD or REF must be instantiated.  If REF is
instantiated, then '(HEAD :- BODY)' is unified with the clause
identified by REF.  (If this clause is a unit-clause, then BODY is
unified with 'true'.)

   If the predicate did not previously exist, then it is created as a
dynamic predicate and 'clause/2' fails.  If REF is not instantiated,
then 'clause/3' behaves exactly like 'clause/2' except that the database
reference is returned.

   By default, clauses are accessed with respect to the source module.

Backtracking
------------

Can be used to backtrack through all the clauses matching a given HEAD
and BODY.  It fails when there are no (or no further) matching clauses
in the database.

Exceptions
----------

'instantiation_error'
     Neither HEAD nor REF is instantiated.

'type_error'
     HEAD is not a callable, or REF is not a well-formed db_reference

'permission_error'
     Procedure is not dynamic.

'existence_error'
     REF is a well-formed db_reference but does not correspond to an
     existing clause or record.

Comments
--------

If 'clause/[2,3]' is called on an undefined procedure, then it fails,
but before failing it makes the procedure dynamic.  This can be useful
if you wish to prevent unknown procedure catching from happening on a
call to that procedure.

   It is not a limitation that HEAD is required to be instantiated in
'clause(HEAD, BODY)', because if you want to backtrack through all
clauses for all dynamic procedures, then this can be achieved by:
     | ?- predicate_property(P,dynamic), clause(P,B).

   If there are clauses with a given name and arity in several different
modules, or if the module for some clauses is not known, then the
clauses can be accessed by first finding the module(s) by means of
'current_predicate/2'.  For example, if the procedure is 'f/1':
     | ?- current_predicate(_,M:f(_)), clause(M:f(X),B).

   'clause/3' will only access clauses that are defined in, or imported
into, the source module, except that the source module can be overridden
by explicitly naming the appropriate module.  For example:
     | ?- assert(foo:bar,R).

     R = '$ref'(771292,1)

     | ?- clause(H,B,'$ref'(771292,1)).

     no
     | ?- clause(foo:H,B,'$ref'(771292,1)).

     H = bar,
     B = true

   Accessing a clause using 'clause/2' uses first argument indexing when
possible, in just the same way that calling a procedure uses first
argument indexing.  See *note Indexing::.

   'clause/2' is part of the ISO Prolog standard; 'clause/3' is not.

See Also
--------

'instance/2', 'assert/[1,2]', 'dynamic/1', 'retract/1', *note
ref-mdb-acl::.


File: sicstus.info,  Node: mpg-ref-close,  Next: mpg-ref-compare,  Prev: mpg-ref-clause,  Up: mpg-bpr

11.3.39 'close/[1,2]'   ISO
---------------------------

Synopsis
--------

'close(+STREAM)'

   'close(+STREAM, +OPTIONS)'

   closes the stream corresponding to STREAM.

Arguments
---------

STREAM
     "stream_object", must be ground

     Stream or file specification.

OPTIONS
     "list of term", must be ground

     A list of zero or more of the following:

     'force(BOOLEAN)'
          Specifies whether SICStus Prolog is to close the stream
          forcefully, even in the presence of errors ('true'), or not
          ('false').  The latter is the default.  Currently this option
          has no effect.

     'direction(+DIRECTION)'
          DIRECTION is an atom specifying the direction or directions to
          close.

          One of:
          'input'
               Close only the input direction, if open.
          'output'
               Close only the output direction, if open.
          'all'
               Close all directions.  This is the default.
          if stream is not open in the specified direction then the call
          to 'open/4' does nothing.

          Closing a single direction is mainly useful when dealing with
          bidirectional streams, such as sockets.

Description
-----------

If STREAM is a stream object, then if the corresponding stream is open,
then it will be closed in the specified directions; otherwise, an error
exception is raised.

   If STREAM is a file specification, then the corresponding stream will
be closed in the specified directions, provided that the file was opened
by 'see/1' or 'tell/1'.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'instantiation_error'
     OPTIONS is not instantiated enough.

'type_error'
     OPTIONS is not a proper list.

'domain_error'
     OPTIONS contains an invalid option.

'permission_error'
     File not opened by 'see/1' or 'tell/1'.

'domain_error'
     STREAM is neither a filename nor a stream.

Examples
--------

In this example, 'foo' will be closed:
     see(foo),
     ...
     close(foo)

   However, in this example, a permission error will be raised and 'foo'
will not be closed:
     open(foo, read, S),
     ...
     close(foo)

   Here, 'close(S)' should have been used.

See Also
--------

'see/1', 'tell/1', 'open/[3,4]', *note ref-iou-sfh::, *note
lib-sockets::.


File: sicstus.info,  Node: mpg-ref-compare,  Next: mpg-ref-compile,  Prev: mpg-ref-close,  Up: mpg-bpr

11.3.40 'compare/3'   ISO
-------------------------

Synopsis
--------

'compare(-ORDER, +TERM1, +TERM2)'

   succeeds if the result of comparing terms TERM1 and TERM2 is ORDER

Arguments
---------

ORDER
     "order"

     '='
          if TERM1 is identical to TERM2,
     '<'
          if TERM1 is before TERM2 in the standard order,
     '>'
          if TERM1 is after TERM2 in the standard order.

TERM1
     "term"

TERM2
     "term"

Description
-----------

The standard order is described in *note ref-lte-cte::.  Note that the
standard order is not, in general, well defined for cyclic terms.

   The goal (A) is equivalent to (B):
     | ?- compare(=, Term1, Term2).  (A)

     |?- (Term1 == Term2).  (B)

   The following query succeeds, binding R to '<', because 1 comes
before 2 in the standard order.
      | ?- compare(R, 1, 2).

     R = <

   If ORDER is supplied, and is not one of '<', '>', or '=', then an
error is thrown, as follows.

Exceptions
----------

'type_error(atom, Order)'
     if ORDER is neither a variable nor an atom.

'domain_error(order, Order)'
     if ORDER is an atom but not '<', '=', or '>'.

   These errors were added in SICStus Prolog 4.3 for alignment with the
ISO Prolog standard.  Previous versions of SICStus Prolog simply failed
instead of reporting an error.

See Also
--------

'@</2', '@=</2', '@>/2', '@>=/2', 'SP_compare()', *note ref-lte-cte::.


File: sicstus.info,  Node: mpg-ref-compile,  Next: mpg-ref-compound,  Prev: mpg-ref-compare,  Up: mpg-bpr

11.3.41 'compile/1'
-------------------

Synopsis
--------

'compile(+FILES)'

   Compiles the specified Prolog source file(s) into memory.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

Description
-----------

This predicate is defined as if by:
     compile(Files) :-
             load_files(Files, [load_type(source),compilation_mode(compile)]).

Exceptions
----------

See 'load_files/[2,3]'.

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-compound,  Next: mpg-ref-consult,  Prev: mpg-ref-compile,  Up: mpg-bpr

11.3.42 'compound/1'   ISO
--------------------------

Synopsis
--------

'compound(+TERM)'

   TERM is currently instantiated to a compound term.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- compound(9).

     no
     | ?- compound(a(1,2,3)).

     yes
     | ?- compound("a").

     yes
     | ?- compound([1,2]).

     yes

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-consult,  Next: mpg-ref-copy_term,  Prev: mpg-ref-compound,  Up: mpg-bpr

11.3.43 'consult/1'
-------------------

Synopsis
--------

'consult(+FILES)'

   Consults the specified Prolog source file(s) into memory.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extensions
     optional.

Description
-----------

This predicate is defined as if by:
     consult(Files) :-
             load_files(Files, [load_type(source),compilation_mode(consult)]).

Exceptions
----------

See 'load_files/[2,3]'.

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-copy_term,  Next: mpg-ref-coverage_data,  Prev: mpg-ref-consult,  Up: mpg-bpr

11.3.44 'copy_term/[2,3]'   ISO
-------------------------------

Synopsis
--------

'copy_term(+TERM, -COPY)'

   Unifies COPY with a copy of TERM in which all variables have been
replaced by brand new variables, and all mutables by brand new mutables.

   'copy_term(+TERM, -COPY, -BODY)'

   Furthermore, if TERM contains variables with goals blocked on them,
or variables with attributes that can be interpreted as a goal (*note
lib-atts::), then BODY is unified with the conjunction of such goals.
If no such goals are present, then BODY is unified with the atom 'true'.
The idea is that executing BODY will reinstate blocked goals and
attributes on the variables in COPY equivalent to those on the variables
in TERM.

Arguments
---------

TERM
     "term"

COPY
     "term"

BODY
     "callable"

Description
-----------

Independent copies are substituted for any mutable terms in TERM.  It
behaves as if defined by:

     copy_term(X, Y) :-
             assert('copy of'(X)),
             retract('copy of'(Y)).

   The implementation of 'copy_term/2' endeavors to conserve space by
not copying ground subterms.

   When you call 'clause/[2,3]' or 'instance/2', you get a new copy of
the term stored in the database, in precisely the same sense that
'copy_term/2' gives you a new copy.

Examples
--------

   * A naive way to attempt to find out whether one term is a copy of
     another:

          identical_but_for_variables(X, Y) :-
             \+ \+ (
                numbervars(X, 0, N),
                numbervars(Y, 0, N),
                X = Y
             ).

     This solution is sometimes sufficient, but will not work if the two
     terms have any variables in common.

   * If you want the test to succeed even when the two terms do have
     some variables in common, then you need to copy one of them; for
     example,
          identical_but_for_variables(X, Y) :-
             \+ \+ (
                copy_term(X, Z),
                numbervars(Z, 0, N),
                numbervars(Y, 0, N),
                Z = Y
             ).

   * An example of 'copy_term/3'.  Suppose that you want to make
     'copy_term/3' aware of the attribute 'tfs/1' in some module.  Then
     with the module-file:

          :- module(foo, []).

          :- use_module(library(atts)).
          :- attribute tfs/1.

          attribute_goal(X, put_atts(X,tfs(Y))) :-
              get_atts(X, tfs(Y)).

     the following query works:

          | ?- foo:put_atts(X, tfs(ind)), copy_term(f(X), Copy, Body).
          Body = foo:put_atts(_A,tfs(ind)),
          Copy = f(_A),
          put_atts(X,tfs(ind)) ? <RET>
          yes

Comments
--------

'copy_term/2' is part of the ISO Prolog standard; 'copy_term/3' is not.

Exceptions
----------

None.

See Also
--------

*note ref-lte-cpt::.


File: sicstus.info,  Node: mpg-ref-coverage_data,  Next: mpg-ref-create_mutable,  Prev: mpg-ref-copy_term,  Up: mpg-bpr

11.3.45 'coverage_data/1'   development
---------------------------------------

Synopsis
--------

'coverage_data(-DATA)'   since release 4.2

   DATA is the coverage data accumulated so far.

Arguments
---------

DATA
     "list of coverage_pair"

     where:

     COVERAGE_PAIR      ::=
                        'counter(FILENAME,PRED_SPEC,CLAUSENO,LINENO)-TAGGED_HITS'
     FILENAME           ::= ATOM {file containing coverage site}
     CLAUSENO           ::= INTEGER {file relative clause number containing
                        coverage site}
     LINENO             ::= INTEGER {line of code containing coverage site}
     TAGGED_HITS        ::= 'det(HITS)' {no nondet calls made from site}
                        | 'nondet(HITS)' {some nondet calls made from site}
     HITS               ::= INTEGER {number of times that coverage site was
                        hit}

Description
-----------

The coverage data accumulated so far is collected into a term of type
"list of coverage_pair" and unified with DATA.

   *Please note*: A given line of code can contain more than one
coverage site.

Exceptions
----------

None.

See Also
--------

*note Coverage Analysis::.


File: sicstus.info,  Node: mpg-ref-create_mutable,  Next: mpg-ref-current_atom,  Prev: mpg-ref-coverage_data,  Up: mpg-bpr

11.3.46 'create_mutable/2'
--------------------------

Synopsis
--------

'create_mutable(+DATUM, -MUTABLE)'

   MUTABLE is a new mutable term with initial value DATUM.

Arguments
---------

DATUM
     "term", must be nonvar

MUTABLE
     "mutable"

Exceptions
----------

'instantiation_error'
     DATUM is uninstantiated

See Also
--------

*note ref-lte-mut::.


File: sicstus.info,  Node: mpg-ref-current_atom,  Next: mpg-ref-current_breakpoint,  Prev: mpg-ref-create_mutable,  Up: mpg-bpr

11.3.47 'current_atom/1'
------------------------

Synopsis
--------

'current_atom(?ATOM)'

   ATOM is a currently existing atom.

Arguments
---------

ATOM
     "atom"

Backtracking
------------

If ATOM is uninstantiated, then 'current_atom/1' can be used to
enumerate all known atoms.  The order in which atoms are bound to ATOM
on backtracking corresponds to the times of their creation.

Comments
--------

Note that the predicate 'atom/1' is recommended for determining whether
a term is an atom, as 'current_atom/1' will succeed if ATOM is
uninstantiated as well.

Exceptions
----------

None.

See Also
--------

*note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-current_breakpoint,  Next: mpg-ref-current_char_conversion,  Prev: mpg-ref-current_atom,  Up: mpg-bpr

11.3.48 'current_breakpoint/5'   development
--------------------------------------------

Synopsis
--------

'current_breakpoint(-CONDITIONS, -BID, -STATUS, -KIND, -TYPE)'

   There is a breakpoint with conditions CONDITIONS, identifier BID,
enabledness STATUS, kind KIND, and type TYPE.

Arguments
---------

:CONDITIONS
     "term"

     Breakpoint conditions.

BID
     "integer"

     Breakpoint identifier.

STATUS
     "one of '[on,off]'"

     'on' for enabled breakpoints and 'off' for disabled ones

KIND
     "one of '[plain(MFUNC),conditional(MFUNC),generic]'"

     MFUNC is the module qualified functor of the specific breakpoint.

TYPE
     "one of '[debugger,advice]'"

Exceptions
----------

'instantiation_error'
     CONDITIONS not instantiated enough.

'type_error'
     CONDITIONS not a proper list of callable term.

'domain_error'
     CONDITIONS not a proper list of valid breakpoint conditions

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-current_char_conversion,  Next: mpg-ref-current_input,  Prev: mpg-ref-current_breakpoint,  Up: mpg-bpr

11.3.49 'current_char_conversion/2'   ISO
-----------------------------------------

Synopsis
--------

'current_char_conversion(?INCHAR, ?OUTCHAR)'

   INCHAR is currently mapped to OUTCHAR in the character-conversion
mapping, where the two are distinct.

Arguments
---------

INCHAR
     "char"

OUTCHAR
     "char"

Exceptions
----------

'type_error'
     An argument is instantiated not to a "char".

See Also
--------

*note Glossary::.


File: sicstus.info,  Node: mpg-ref-current_input,  Next: mpg-ref-current_key,  Prev: mpg-ref-current_char_conversion,  Up: mpg-bpr

11.3.50 'current_input/1'   ISO
-------------------------------

Synopsis
--------

'current_input(-STREAM)'

   unifies STREAM with the current input stream.

Arguments
---------

STREAM
     "stream_object"

Description
-----------

STREAM is the current input stream.  The current input stream is also
accessed by the C variable 'SP_curin'.

Exceptions
----------

'domain_error'
     STREAM is instantiated not to a valid stream.

See Also
--------

'open/[3,4]', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-current_key,  Next: mpg-ref-current_module,  Prev: mpg-ref-current_input,  Up: mpg-bpr

11.3.51 'current_key/2'
-----------------------

Synopsis
--------

'current_key(?KEYNAME, ?KEYTERM)'

   Succeeds when KEYNAME is the name of KEYTERM, and KEYTERM is a
recorded key.

Arguments
---------

KEYNAME
     "atomic"

     One of:
        * KEYTERM, if KEYTERM is atomic; or
        * the principal functor of KEYTERM, if KEYTERM is a compound
          term.

KEYTERM
     "term"

     The most general form of the key for a currently recorded term.

Description
-----------

This predicate can be used to enumerate in undefined order all keys for
currently recorded terms through backtracking.

Backtracking
------------

Enumerates all keys through backtracking.

Exceptions
----------

None.

See Also
--------

*note ref-mdb-idb::.


File: sicstus.info,  Node: mpg-ref-current_module,  Next: mpg-ref-current_op,  Prev: mpg-ref-current_key,  Up: mpg-bpr

11.3.52 'current_module/[1,2]'
------------------------------

Synopsis
--------

'current_module(?MODULENAME)'

   Queries whether a module is "current" or backtracks through all of
the current modules.

   'current_module(?MODULENAME, ?ABSFILE)'

   Associates modules with their module-files.

Arguments
---------

MODULENAME
     "atom"

ABSFILE
     "atom"

     Absolute filename in which the module is defined.

Description
-----------

A loaded module becomes "current" as soon as some predicate is defined
in it, and a module can never lose the property of being current.

   It is possible for a current module to have no associated file, in
which case 'current_module/1' will succeed on it but 'current_module/2'
will fail.  This arises for the special module 'user' and for
dynamically-created modules (*note ref-mod::).

   If its arguments are not correct, or if MODULE has no associated
file, then 'current_module/2' simply fails.

Backtracking
------------

'current_module/1' backtracks through all of the current modules.  The
following command will print out all current modules:
     | ?- current_module(Module), writeq(Module), nl, fail.

   'current_module/2' backtracks through all of the current modules and
their associated files.

Exceptions
----------

'type_error'

Examples
--------

     | ?- findall(M,current_module(M),Ms).
     Ms = [chr,user,prolog,'SU_messages',clpfd] ? <RET>
     yes
     | ?- findall(M-F,current_module(M,F),MFs).
     MFs = ['SU_messages'-'/src/sicstus/matsc/sicstus4/Utils/x86-linux-glibc2.3/bin/sp-4.1.0/sicstus-4.1.0/library/SU_messages.pl'] ?
     yes

See Also
--------

*note ref-mod-ilm::.


File: sicstus.info,  Node: mpg-ref-current_op,  Next: mpg-ref-current_output,  Prev: mpg-ref-current_module,  Up: mpg-bpr

11.3.53 'current_op/3'   ISO
----------------------------

Synopsis
--------

'current_op(?PRECEDENCE, ?TYPE, ?NAME)'

   Succeeds when the atom NAME is currently an operator of type TYPE and
precedence PRECEDENCE.

Arguments
---------

PRECEDENCE
     "integer", in the range 1-1200

TYPE
     "one of '[xfx, xfy, yfx, fx, xf, yf]'"

NAME
     "atom"

Description
-----------

None of the arguments need be instantiated at the time of the call; that
is, this predicate can be used to find the precedence or type of an
operator or to backtrack through all operators.

   To add or remove an operator, use 'op/3'.

Exceptions
----------

'type_error'
     NAME not an atom or TYPE not an atom or PRECEDENCE not an integer.

'domain_error'
     PRECEDENCE not between 1-1200, or TYPE not one of listed atoms.

Examples
--------

See Also
--------

'op/3', *note ref-syn-ops::.


File: sicstus.info,  Node: mpg-ref-current_output,  Next: mpg-ref-current_predicate,  Prev: mpg-ref-current_op,  Up: mpg-bpr

11.3.54 'current_output/1'   ISO
--------------------------------

Synopsis
--------

'current_output(-STREAM)'

   unifies STREAM with the current output stream.

Arguments
---------

STREAM
     "stream_object"

Description
-----------

STREAM is the current output stream.  The current output stream is also
accessed by the C variable 'SP_curout'.

Exceptions
----------

'domain_error'
     STREAM is instantiated not to a valid stream.

See Also
--------

'open/[3,4]', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-current_predicate,  Next: mpg-ref-current_prolog_flag,  Prev: mpg-ref-current_output,  Up: mpg-bpr

11.3.55 'current_predicate/[1,2]'   ISO
---------------------------------------

Synopsis
--------

'current_predicate(?PREDSPEC)'

   Unifies PREDSPEC with a predicate specifications of the form
NAME/ARITY.

   'current_predicate(?NAME, ?TERM)'

   Unifies NAME with the name of a user-defined predicate, and TERM with
the most general term corresponding to that predicate.

Arguments
---------

:PREDSPEC
     "pred_spec"

NAME
     "atom"

:TERM
     "callable"

Description
-----------

If you have loaded the predicates 'foo/1' and 'foo/3' into Prolog, then
'current_predicate/2' would return the following:
      | ?- current_predicate(foo, T).

     T = foo(_A) ;

     T = foo(_A,_B,_C) ;

     no

Examples
--------

   * The following goals can be used to backtrack through every
     predicate in your program.

          | ?- current_predicate(Name, Module:Term).

          | ?- current_predicate(Module:PredSpec).

   * If a module is specified, then 'current_predicate/[1,2]' only
     succeeds for those predicates that are _defined_ in the module.  It
     fails for those predicates that are imported into a module.

          | ?- current_predicate(m:P).

     will backtrack through all predicates 'P' that are defined in
     module 'm'.  To backtrack through all predicates imported by a
     module use 'predicate_property/2' (*note ref-lps-ove::).

   To find out whether a predicate is built-in, use
'predicate_property/2'.

     % Is there a callable predicate named 'gc'?

     | ?- current_predicate(gc, Term).

     no
     | ?- predicate_property(gc, Prop)

     Prop = built_in

Exceptions
----------

'instantiation_error'
'type_error'
     in PREDSPEC

Comments
--------

'current_predicate/1' is part of the ISO Prolog standard;
'current_predicate/2' is not.

See Also
--------

'predicate_property/2', *note ref-lps-ove::.


File: sicstus.info,  Node: mpg-ref-current_prolog_flag,  Next: mpg-ref-current_stream,  Prev: mpg-ref-current_predicate,  Up: mpg-bpr

11.3.56 'current_prolog_flag/2'   ISO
-------------------------------------

Synopsis
--------

'current_prolog_flag(?FLAGNAME, ?VALUE)'

   same as 'prolog_flag(FLAGNAME, VALUE)', except that
'current_prolog_flag(FLAGNAME, VALUE)' type checks FLAGNAME.

Arguments
---------

FLAGNAME
     "atom"

VALUE
     "term"

Exceptions
----------

'type_error'
     FLAGNAME is not an atom.

'domain_error'
     FLAGNAME is not a valid flag name.

See Also
--------

'prolog_flag/[2,3]', 'set_prolog_flag/2', *note ref-lps-flg::.


File: sicstus.info,  Node: mpg-ref-current_stream,  Next: mpg-ref-cut,  Prev: mpg-ref-current_prolog_flag,  Up: mpg-bpr

11.3.57 'current_stream/3'
--------------------------

Synopsis
--------

'current_stream(?ABSFILE, ?MODE, ?STREAM)'

   STREAM is a stream, which is currently open on file ABSFILE in mode
MODE.

Arguments
---------

ABSFILE
     "atom"

     Absolute filename.

MODE
     for streams opened with 'open/[3,4]' this is "one of '[read, write,
     append]'".  For other streams MODE may have other values.

STREAM
     "stream_object"

Description
-----------

   * None of the arguments need be initially instantiated.
   * 
     Ignores certain pre-defined streams, e.g. the streams initially
     associated with 'user_input', 'user_output' and 'user_error' will
     not be recognized or generated by 'current_stream/3'.

     This is unlike 'stream_property/2', which can backtrack over all
     streams, including the pre-defined ones.

Backtracking
------------

Can be used to backtrack through all open streams.

Exceptions
----------

None.

See Also
--------

'open/[3,4]', *note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-cut,  Next: mpg-ref-db_reference,  Prev: mpg-ref-current_stream,  Up: mpg-bpr

11.3.58 '!/0'   ISO
-------------------

Synopsis
--------

'!'

   Cut.

Description
-----------

When first encountered as a goal, cut succeeds immediately.  If
backtracking should later return to the cut, then the parent goal will
fail (the parent goal is the one that matched the head of the clause
containing the cut).

Exceptions
----------

None.

See Also
--------

*note ref-sem-ctr-cut::.


File: sicstus.info,  Node: mpg-ref-db_reference,  Next: mpg-ref-debug,  Prev: mpg-ref-cut,  Up: mpg-bpr

11.3.59 'db_reference/1'
------------------------

Synopsis
--------

'db_reference(+TERM)'   since release 4.1

   TERM is currently instantiated to a compound term with principal
functor ''$ref'/2' denoting a unique reference to a dynamic clause.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- db_reference(9).

     no

     | ?- db_reference(_X).

     no

     | ?- assertz(foo(a), R), db_reference(R).

     R = '$ref'(1816730,128)

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-debug,  Next: mpg-ref-debugger_command_hook,  Prev: mpg-ref-db_reference,  Up: mpg-bpr

11.3.60 'debug/0'   development
-------------------------------

Synopsis
--------

'debug'

   Turns on the debugger in debug mode.

Description
-----------

'debug/0' turns the debugger on and sets it to debug mode.  Turning the
debugger on in debug mode means that it will stop at the next spypoint
encountered in the current execution.

   The effect of this predicate can also be achieved by typing the
letter 'd' after a '^C' interrupt (*note Execution::).

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-debugger_command_hook,  Next: mpg-ref-debugging,  Prev: mpg-ref-debug,  Up: mpg-bpr

11.3.61 'debugger_command_hook/2'   hook, development
-----------------------------------------------------

Synopsis
--------

':- multifile user:debugger_command_hook/2.'

   'user:debugger_command_hook(+DCOMMAND, -ACTIONS)'

   Allows the interactive debugger to be extended with user-defined
commands.  *Note Debug Commands::.

Arguments
---------

DCOMMAND
     "term"

ACTIONS
     "term"

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

*note Breakpoint Predicates::.


File: sicstus.info,  Node: mpg-ref-debugging,  Next: mpg-ref-dif,  Prev: mpg-ref-debugger_command_hook,  Up: mpg-bpr

11.3.62 'debugging/0'   development
-----------------------------------

Synopsis
--------

'debugging'

   Prints out current debugging state

Description
-----------

'debugging/0' displays information on the terminal about the current
debugging state.  It shows

   * The top-level state of the debugger, which is one of

     'debug'
          The debugger is on but will not show anything or stop for user
          interaction until a spypoint is reached.

     'trace'
          The debugger is on and will show everything.  As soon as you
          type a goal, you will start seeing a debugging trace.  After
          printing each trace message, the debugger may or may not stop
          for user interaction: this depends on the type of leashing in
          force (see below).

     'zip'
          The debugger is on but will not show anything or stop for user
          interaction until a spypoint is reached.  The debugger does
          not even keep any information of the execution of the goal
          till the spypoint is reached and hence you will not be able to
          see the ancestors of the goal when you reach the spypoint.

     'off'
          The debugger is off.

     The top-level state can be controlled by the predicates 'debug/0',
     'nodebug/0', 'trace/0', 'notrace/0' 'zip/0', 'nozip/0', and
     'prolog_flag/3'.

   * The type of leashing in force.  When the debugger prints a message
     saying that it is passing through a particular port (one of Call,
     Exit, Redo, Fail, or Exception) of a particular procedure, it stops
     for user interaction only if that port is leashed.  The predicate
     'leash/1' can be used to select which of the seven ports you want
     to be leashed.
   * All the current spypoints.  Spypoints are controlled by the
     predicates 'spy/[1,2]', 'nospy/1', 'nospyall/0',
     'add_breakpoint/2', 'disable_breakpoints/1',
     'enable_breakpoints/1', and 'remove_breakpoints/1'.

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: mpg-ref-dif,  Next: mpg-ref-disable_breakpoints,  Prev: mpg-ref-debugging,  Up: mpg-bpr

11.3.63 'dif/2'
---------------

Synopsis
--------

'dif(+X,+Y)'

   Constrains X and Y to represent different terms i.e. to be
non-unifiable.

Arguments
---------

X
     "term"

Y
     "term"

Description
-----------

Calls to 'dif/2' either succeed, fail, or are blocked depending on
whether X and Y are sufficiently instantiated.  It is defined as if by:

     dif(X, Y) :- when(?=(X,Y), X\==Y).

Exceptions
----------

None.

See Also
--------

*note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-disable_breakpoints,  Next: mpg-ref-discontiguous,  Prev: mpg-ref-dif,  Up: mpg-bpr

11.3.64 'disable_breakpoints/1'   development
---------------------------------------------

Synopsis
--------

'disable_breakpoints(+BIDS)'

   Disables the breakpoints specified by BIDS.

Arguments
---------

BIDS
     "list of integer", must be ground

     Breakpoint identifiers.

Exceptions
----------

'instantiation_error'
'type_error'
     in BIDS

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-discontiguous,  Next: mpg-ref-display,  Prev: mpg-ref-disable_breakpoints,  Up: mpg-bpr

11.3.65 'discontiguous/1'   declaration, ISO
--------------------------------------------

Synopsis
--------

':- discontiguous +PREDSPECS'

   Declares the clauses of the predicates defined by PREDSPECS to be
discontiguous in the source file (suppresses compile-time warnings).

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of such
     separated by commas.

Comments
--------

'discontiguous' is not an ISO predefined prefix operator.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'instantiation_error'
     PREDSPECS not ground.

'type_error'
     PREDSPECS not a valid "pred_spec_forest".

'domain_error'
     Some arity is an integer < 0.

'representation_error'
     Some arity is an integer > 255.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Discontiguous Declarations::.


File: sicstus.info,  Node: mpg-ref-display,  Next: mpg-ref-do,  Prev: mpg-ref-discontiguous,  Up: mpg-bpr

11.3.66 'display/1'
-------------------

Synopsis
--------

'display(+TERM)'

   Writes TERM on the standard output stream, without quoting atoms, in
functional notation, without treating ''$VAR'/1' terms specially.

   Since quoting is never used, even when needed for reading the term
back in, the standard predicate 'write_canonical/1' is often preferable.

Arguments
---------

TERM
     "term"

Description
-----------

'display(Term)' is equivalent to:

     write_term(Term, [ignore_ops(true)])

Examples
--------

     | ?- display(a+b).
     +(a,b)
     yes

     | ?- read(X), display(X), nl.
     |: a + b * c.
     +(a,*(b,c))

     X = a+b*c

     | ?-

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-do,  Next: mpg-ref-dynamic,  Prev: mpg-ref-display,  Up: mpg-bpr

11.3.67 'do/2'
--------------

Synopsis
--------

'(+ITERATOR do +BODY)'

Arguments
---------

+ITERATOR
     "iterator", must be nonvar
:BODY
     "callable", must be nonvar

Description
-----------

This control structure reduces the need to write auxiliary predicates
performing simple iterations.  It iterates BODY until ITERATOR's
termination condition is true.

   A "iterator" is a term of one of the following forms:

'fromto(FIRST,IN,OUT,LAST)'
     In the first iteration, IN=FIRST.  In the N:th iteration, IN is the
     value that OUT had at the end of the (N-1):th iteration.  IN and
     OUT are local variables in BODY.  The termination condition is
     'OUT=LAST'.

'foreach(X,LIST)'
     Iterate BODY with X ranging over all elements of LIST.  X is a
     local variable in BODY.  Can also be used for constructing a list.
     The termination condition is 'TAIL = []', where TAIL is the suffix
     of LIST that follows the elements that have been iterated over.

'foreacharg(X,STRUCT)'
'foreacharg(X,STRUCT,I)'
     Iterate BODY with X ranging over all arguments of STRUCT and I
     ranging over the argument number, 1-based.  X and I are local
     variables in BODY.  Cannot be used for constructing a term.  So the
     termination condition is true iff all arguments have been iterated
     over.

'count(I,MINEXPR,MAX)'
     This is normally used for counting the number of iterations.  Let
     MIN take the value 'integer(MINEXPR)'.  Iterate BODY with I ranging
     over integers from MIN.  I is a local variable in BODY.  The
     termination condition is 'I = MAX', i.e.  MAX can be and typically
     is a variable.

'for(I,MINEXPR,MAXEXPR)'
     This is used when the number of iterations is known.  Let MIN take
     the value 'integer(MINEXPR)', let MAX take the value
     'integer(MAXEXPR)', and let PAST take the value 'max(MIN,MAX+1)'.
     Iterate BODY with I ranging over integers from MIN to
     'max(MIN,MAX)' inclusive.  I is a local variable in BODY.  The
     termination condition is 'I = PAST'.

'param(X)'
     For declaring variables in BODY global, i.e.  shared with the
     context.  X can be a single variable, or a list of them.  The
     termination condition is true.  *Please note*: By default,
     variables in BODY have local scope.

'"iterator","iterator"'
     The iterators are iterated synchronously; that is, they all take
     their first value for the first execution of BODY, their second
     value for the second execution of BODY, etc.  The order in which
     they are written does not matter, and the set of local variables in
     BODY is the union of those of the iterators.  The termination
     condition is the conjunction of those of the iterators.

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem-ctr-dol::.


File: sicstus.info,  Node: mpg-ref-dynamic,  Next: mpg-ref-enable_breakpoints,  Prev: mpg-ref-do,  Up: mpg-bpr

11.3.68 'dynamic/1'   declaration, ISO
--------------------------------------

Synopsis
--------

':- dynamic +PREDSPECS'

   Declares the clauses of the predicates defined by PREDSPECS to be
dynamic.

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of such
     separated by commas.

Comments
--------

'dynamic' is not an ISO predefined prefix operator.

   To declare a grammar rule GRAM/N dynamic, the arity of PREDSPECS must
be N+2.

   Exceptions in the context of loading code are printed as error
messages.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'instantiation_error'
     PREDSPECS not ground.

'type_error'
     PREDSPECS not a valid "pred_spec_forest".

'domain_error'
     Some arity is an integer < 0.

'representation_error'
     Some arity is an integer > 255.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Dynamic Declarations::.


File: sicstus.info,  Node: mpg-ref-enable_breakpoints,  Next: mpg-ref-ensure_loaded,  Prev: mpg-ref-dynamic,  Up: mpg-bpr

11.3.69 'enable_breakpoints/1'   development
--------------------------------------------

Synopsis
--------

'enable_breakpoints(+BIDS)'

   Enables the breakpoints specified by BIDS.

Arguments
---------

BIDS
     "list of integer", must be ground

     Breakpoint identifiers.

Exceptions
----------

'instantiation_error'
'type_error'
     in BIDS

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-ensure_loaded,  Next: mpg-ref-equal_to,  Prev: mpg-ref-enable_breakpoints,  Up: mpg-bpr

11.3.70 'ensure_loaded/1'   ISO
-------------------------------

Synopsis
--------

'ensure_loaded(+FILES)'

   Loads the specified Prolog source and/or object file(s) into memory,
if not already loaded and up to date.

Arguments
---------

:FILES
     "file_spec" or "list of file_spec", must be ground

     A file specification or a list of file specifications; extension
     optional.

Description
-----------

The recommended style is to use this predicate for non-module-files
only, but if any module-files are encountered, then their public
predicates are imported.

   This predicate is defined as if by:
     ensure_loaded(Files) :-
             load_files(Files, [if(changed)]).

Exceptions
----------

See 'load_files/[2,3]'.

See Also
--------

*note ref-lod-lod::.


File: sicstus.info,  Node: mpg-ref-equal_to,  Next: mpg-ref-erase,  Prev: mpg-ref-ensure_loaded,  Up: mpg-bpr

11.3.71 '=:=/2'   ISO
---------------------

Synopsis
--------

+EXPR1 '=:=' +EXPR2

   Succeeds if the results of evaluating EXPR1 and EXPR2 _are equal_.

Arguments
---------

EXPR1
     "expr", must be ground
EXPR2
     "expr", must be ground

Description
-----------

Evaluates EXPR1 and EXPR2 as arithmetic expressions and compares the
results.

Exceptions
----------

Arithmetic errors (*note ref-ari-exc::).

Examples
--------

     | ?- 1.0 + 1.0 =:= 2.

     yes

     | ?- "a" =:= 97.

     yes

See Also
--------

*note ref-ari::


File: sicstus.info,  Node: mpg-ref-erase,  Next: mpg-ref-error_exception,  Prev: mpg-ref-equal_to,  Up: mpg-bpr

11.3.72 'erase/1'
-----------------

Synopsis
--------

'erase(+REF)'

   Erases from the database the dynamic clause or recorded term
referenced by REF.

Arguments
---------

REF
     "db_reference", must be nonvar

Description
-----------

Erases from the database the dynamic clause or recorded term referenced
by REF.

   REF must be a database reference to an existing clause or recorded
term.

   'erase/1' is not sensitive to the source module; that is, it can
erase a clause even if that clause is neither defined in nor imported
into the source module.

Exceptions
----------

'instantiation_error'

     If REF is not instantiated.

'type_error'

     If REF is not a database reference.

'existence_error'

     if REF is not a database reference to an existing clause or
     recorded term.

Examples
--------

See Also
--------

*note ref-mdb-rcd::.


File: sicstus.info,  Node: mpg-ref-error_exception,  Next: mpg-ref-execution_state,  Prev: mpg-ref-erase,  Up: mpg-bpr

11.3.73 'error_exception/1'   hook, development
-----------------------------------------------

Synopsis
--------

':- multifile user:error_exception/1.'

   'user:error_exception(+EXCEPTION)'

   Tells the debugger to enter trace mode on exceptions matching
EXCEPTION.

Arguments
---------

EXCEPTION
     "term"

Exceptions
----------

None.

See Also
--------

*note Exceptions Debug::.


File: sicstus.info,  Node: mpg-ref-execution_state,  Next: mpg-ref-exists,  Prev: mpg-ref-error_exception,  Up: mpg-bpr

11.3.74 'execution_state/[1,2]'   development
---------------------------------------------

Synopsis
--------

'execution_state(+TESTS)'

   TESTS are satisfied in the current state of the execution.

   'execution_state(+FOCUSCONDITIONS, +TESTS)'

   TESTS are satisfied in the state of the execution pointed to by
FOCUSCONDITIONS.

Arguments
---------

FOCUSCONDITIONS
     "term"

:TESTS
     "term"

Exceptions
----------

'instantiation_error'
     An argument not instantiated enough.

'type_error'
     An argument not a proper list of callable term.

'domain_error'
     An argument not a proper list of valid conditions and tests.

See Also
--------

*note Built-in Predicates for Breakpoint Handling::, *note Breakpoint
Predicates::.


File: sicstus.info,  Node: mpg-ref-exists,  Next: mpg-ref-expand_term,  Prev: mpg-ref-execution_state,  Up: mpg-bpr

11.3.75 '^/2'
-------------

Synopsis
--------

+X '^' +P

   Equivalent to "there exists an X such that P is true", thus X is
normally an unbound variable.  The use of the explicit existential
quantifier outside 'setof/3' and 'bagof/3' is superfluous.

Arguments
---------

X
     "term"
:P
     "callable", must be nonvar

Description
-----------

Equivalent to simply calling P.

Backtracking
------------

Depends on P.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

Using 'bagof/3' without and with the existential quantifier:
     | ?- bagof(X, foo(X,Y), L).

     X = _3342,
     Y = 2,
     L = [1,1] ;

     X = _3342,
     Y = 3,
     L = [2] ;

     no

     | ?- bagof(X, Y^foo(X,Y), L).

     X = _3342,
     Y = _3361,
     L = [1,1,2] ;

     no

See Also
--------

'setof/3', 'bagof/3', *note ref-all::.


File: sicstus.info,  Node: mpg-ref-expand_term,  Next: mpg-ref-fail,  Prev: mpg-ref-exists,  Up: mpg-bpr

11.3.76 'expand_term/2'   hookable
----------------------------------

Synopsis
--------

'expand_term(+TERM1, -TERM2)'

   Transforms source file terms into Prolog clauses before they are
compiled.  Normally called by the compiler, but can be called directly.
The transform can be customized by defining 'user:term_expansion/6'.

   When a source file is loaded, except by ':- include', 'expand_term/2'
is called with the virtual clauses 'beginning_of_file' before and
'end_of_file' after the real Prolog clauses, to give
'user:term_expansion/6' an opportunity to perform some action at the
beginning and end of a source file.  *Please note*: the virtual clause
'beginning_of_file' is "seen" _before_ any module declaration, i.e.
before the source module has been updated.

Arguments
---------

TERM1
     "term"

TERM2
     "term"

Description
-----------

Usually called by the built-in predicates that read code and not
directly by user programs.

   in particular used to translate grammar rules, written with '-->/2',
into ordinary Prolog clauses, written with ':-/2'.  If TERM1 is a
grammar rule, then TERM2 is the corresponding clause.  Otherwise TERM2
is simply TERM1 unchanged.

   Calls 'user:term_expansion/6'.

Exceptions
----------

Prints messages for exceptions raised by 'user:term_expansion/6'.

See Also
--------

'phrase/[2,3]', '-->/2', *note ref-lod-exp::.


File: sicstus.info,  Node: mpg-ref-fail,  Next: mpg-ref-false,  Prev: mpg-ref-expand_term,  Up: mpg-bpr

11.3.77 'fail/0'   ISO
----------------------

Synopsis
--------

'fail'

   Always fails.

Exceptions
----------

None.

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-false,  Next: mpg-ref-file_search_path,  Prev: mpg-ref-fail,  Up: mpg-bpr

11.3.78 'false/0'   ISO
-----------------------

Synopsis
--------

'false'

   Always fails (same as 'fail/0').

Exceptions
----------

None.

See Also
--------

*note ref-sem::.


File: sicstus.info,  Node: mpg-ref-file_search_path,  Next: mpg-ref-findall,  Prev: mpg-ref-false,  Up: mpg-bpr

11.3.79 'file_search_path/2'   hook
-----------------------------------

Synopsis
--------

':- multifile user:file_search_path/2.'

   'user:file_search_path(+PATHALIAS, +DIRSPEC)'

   Defines a symbolic name for a directory or a path.  Used by
predicates taking "file_spec" as input argument.

Arguments
---------

PATHALIAS
     "atom"

     An atom that represents the path given by DIRSPEC.

DIRSPEC
     "file_spec"

     Either an atom giving the path to a file or directory, or
     PATHALIAS(DIRSPEC), where PATHALIAS is defined by another
     'file_search_path/2' rule.

Description
-----------

The 'file_search_path' mechanism provides an extensible way of
specifying a sequence of directories to search to locate a file.  For
instance, if a filename is given as a structure term,
'library(between)'.  The principle functor of the term, 'library', is
taken to be another 'file_search_path/2' definition of the form
     file_search_path(library, LibPath)

   and file 'between' is assumed to be relative to the path given by
LIBPATH.  LIBPATH may also be another structure term, in which case
another 'file_search_path/2' fact gives its definition.  The search
continues until the path is resolved to an atom.

   There may also be several definitions for the same PATHALIAS.
Certain predicates, such as 'load_files/[1,2]' and
'absolute_file_name/[2,3]', search all these definitions until the path
resolves to an existing file.

   There are several predefined search paths, such as 'application',
'runtime', 'library', 'system'.  These are tried before the user-defined
ones.

   The predicate is undefined at startup, but behaves as if it were a
multifile predicate with the following clauses.  The system properties
'SP_APP_DIR' and 'SP_RT_DIR' expand respectively to the absolute path of
the directory that contains the executable and the directory that
contains the SICStus runtime (*note System Properties and Environment
Variables::), 'SP_TEMP_DIR' expand to a directory suitable for storing
temporary files.

     file_search_path(library, Path) :-
             library_directory(Path).
     file_search_path(system, Platform) :-
             prolog_flag(host_type, Platform).
     file_search_path(application, '$SP_APP_DIR').
     file_search_path(runtime, '$SP_RT_DIR').
     file_search_path(temp, '$SP_TEMP_DIR').
     file_search_path(path, Dir) :-
             ... backtracks through the $PATH environment variable ...


Examples
--------

     | ?- [user].
     % compiling user...
     | :- multifile user:file_search_path/2.
     | user:file_search_path(home, '/usr/joe_bob').
     | user:file_search_path(review, home('movie/review')).
     | end_of_file.
     % compiled user in module user, 0 msec 768 bytes
     yes
     | ?- compile(review(blob)).
     % compiling /usr/joe_bob/movie/review/blob.pl

Exceptions
----------

All error handling is done by the predicates extended by this hook.

See Also
--------

'absolute_file_name/[2,3]', 'library_directory/1', 'load_files/[1,2]',
*note ref-fdi::, *note ref-lps-flg::, *note System Properties and
Environment Variables::.


File: sicstus.info,  Node: mpg-ref-findall,  Next: mpg-ref-float,  Prev: mpg-ref-file_search_path,  Up: mpg-bpr

11.3.80 'findall/[3,4]'   ISO
-----------------------------

Synopsis
--------

'findall(+TEMPLATE, +GENERATOR, -LIST)'

   'findall(+TEMPLATE, +GENERATOR, -LIST, +REMAINDER)'

   LIST is the list of all the instances of TEMPLATE for which the goal
GENERATOR succeeds, appended to REMAINDER.  REMAINDER defaults to the
empty list.

Arguments
---------

TEMPLATE
     "term"

:GENERATOR
     "callable", must be nonvar

     A goal to be proved as if by 'call/1'.

LIST
     "list of term"

REMAINDER
     "list of term"

Description
-----------

A special case of 'bagof/3', where all free variables in the generator
are taken to be existentially quantified, as if by means of the '^'
operator.  Contrary to 'bagof/3' and 'setof/3', if there are no
instances of TEMPLATE such that GENERATOR succeeds, then LIST =
REMAINDER.

   Because 'findall/[3,4]' avoids the relatively expensive variable
analysis done by 'bagof/3', using 'findall/[3,4]' where appropriate
rather than 'bagof/3' can be considerably more efficient.

   *Please note*: If the instances being gathered contain attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
then those variables are replaced by brand new variables, without
attributes, in LIST.  To retain the attributes, you can use
'copy_term/3' (*note ref-lte-cpt::).

Backtracking
------------

'bagof/3' can succeed nondeterminately, generating alternative values
for SET corresponding to different instantiations of the free variables
of GENERATOR.

Exceptions
----------

Call errors (*note ref-sem-exc::).

Examples
--------

To illustrate the differences among 'findall/3', 'setof/3', and
'bagof/3':
     | ?- [user].
     | foo(1,2).
     | foo(1,2).
     | foo(2,3).
     |
     % user compiled in module user, 0.100 sec 352 bytes

     yes
     | ?- bagof(X, foo(X,Y), L).

     Y = 2,
     L = [1,1] ? ;

     Y = 3,
     L = [2] ? ;

     no

     | ?- bagof(X, Y^foo(X,Y), L).

     L = [1,1,2] ? ;

     no

     | ?- findall(X, foo(X,Y), L).

     L = [1,1,2] ? ;

     no
     | ?- findall(X, foo(X,Y), L, S).

     L = [1,1,2|S] ? ;

     no

     | ?- setof(X, foo(X,Y), L).

     X = _3342,
     Y = 2,
     L = [1] ;

     X = _3342,
     Y = 3,
     L = [2] ;

     no

Comments
--------

'findall/3' is part of the ISO Prolog standard; 'findall/4' is not.

See Also
--------

'bagof/3', 'setof/3', '^/2', *note ref-all::.


File: sicstus.info,  Node: mpg-ref-float,  Next: mpg-ref-flush_output,  Prev: mpg-ref-findall,  Up: mpg-bpr

11.3.81 'float/1'   ISO
-----------------------

Synopsis
--------

'float(+TERM)'

   TERM is currently instantiated to a float.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- float(Term1).

     no
     | ?- float(5.2).

     yes

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-flush_output,  Next: mpg-ref-foreign,  Prev: mpg-ref-float,  Up: mpg-bpr

11.3.82 'flush_output/[0,1]'   ISO
----------------------------------

Synopsis
--------

'flush_output'

   'flush_output(+STREAM)'

   Forces the buffered output of the stream STREAM (defaults to the
current output stream) to be sent to the associated device.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid Prolog stream, defaults to the current output stream.

Description
-----------

Sends the current buffered output of an output stream STREAM to the
actual output device, which is usually a disk or a tty device.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'permission_error'
     An error occurred in flushing out the buffered output.

Examples
--------

See Also
--------

*note ref-iou-sfh::.


File: sicstus.info,  Node: mpg-ref-foreign,  Next: mpg-ref-foreign_resource,  Prev: mpg-ref-flush_output,  Up: mpg-bpr

11.3.83 'foreign/[2,3]'   hook
------------------------------

Synopsis
--------

':- discontiguous foreign/2, foreign/3.'

   'foreign(+ROUTINE, +FOREIGNSPEC)'

   'foreign(+ROUTINE, +LANGUAGE, +FOREIGNSPEC)'

   Describes the interface between Prolog and the foreign ROUTINE.  Used
by 'load_foreign_resource/1'.

Arguments
---------

ROUTINE
     "atom", must be nonvar

     An atom that names a foreign code ROUTINE.

LANGUAGE
     "atom", must be nonvar

     An atom that names the LANGUAGE in which ROUTINE is written.  Can
     only be 'c'.

FOREIGNSPEC
     "foreign_spec", must be ground

     A ground term of the form PREDNAME(ARGSPEC, ..., ARGSPEC) as
     described in *note Conversions between Prolog Arguments and C
     Types::.  Each ARGSPEC should be a "foreign_arg".

Description
-----------

The user has to define a 'foreign/[2,3]' fact for every foreign function
that is to be called from Prolog.  Note that ROUTINE does not have to be
the same as PREDICATENAME.  Arguments are passed to the foreign function
as specified in FOREIGNSPEC.

+TYPE
     specifies that an argument is to be passed to the foreign function.

-TYPE
     specifies that an argument is to be received from the foreign
     function.

[-TYPE]
     argument is used to obtain the return value of a foreign function
     call.  At most one "return value" argument can be specified.

   The 'foreign/[2,3]' facts are used only in the context of a
'load_foreign_resource/1' command and can be removed once the foreign
files are loaded.

   Contrary to most hook predicates which reside in the 'user' module,
'foreign/[2,3]' facts will only be looked up in the source module of the
loading command.

Exceptions
----------

Error handling is performed by 'load_foreign_resource/1'.

See Also
--------

'load_foreign_resource/1', *note Calling C from Prolog::.
